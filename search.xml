<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>mysql 5.7虚拟列 generated columns</title>
    <url>/2021/03/14/mysql-5-7%E8%99%9A%E6%8B%9F%E5%88%97-generated-columns/</url>
    <content><![CDATA[<h3 id="CREATE-TABLE-支持生成的列"><a href="#CREATE-TABLE-支持生成的列" class="headerlink" title="CREATE TABLE 支持生成的列"></a>CREATE TABLE 支持生成的列</h3><p>生成列的值是根据列定义中包含的表达式计算的。<br>下面的简单示例的表，该表存储了 sidea 和 sideb 列中直角三角形的长度，并计算了sidec 中斜边的长度:<span id="more"></span></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> triangle(</span><br><span class="line">    sidea <span class="keyword">DOUBLE</span>,</span><br><span class="line">    sideb <span class="keyword">DOUBLE</span>,</span><br><span class="line">    sidec <span class="keyword">DOUBLE</span> <span class="keyword">AS</span> (<span class="built_in">SQRT</span>(sidea <span class="operator">*</span> sidea <span class="operator">+</span> sideb <span class="operator">*</span> sideb))</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> triangle (sidea, sideb) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">1</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">6</span>, <span class="number">8</span>);</span><br></pre></td></tr></table></figure>
<p>从表中选择会产生以下结果,使用 triangle 表的任何应用程序都可以访问斜边值，而无需指定计算它们的表达式。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> triangle;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------+--------------------+</span></span><br><span class="line"><span class="operator">|</span> sidea <span class="operator">|</span> sideb <span class="operator">|</span> sidec              <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------+--------------------+</span></span><br><span class="line"><span class="operator">|</span>     <span class="number">1</span> <span class="operator">|</span>     <span class="number">1</span> <span class="operator">|</span> <span class="number">1.4142135623730951</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>     <span class="number">3</span> <span class="operator">|</span>     <span class="number">4</span> <span class="operator">|</span>                  <span class="number">5</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>     <span class="number">6</span> <span class="operator">|</span>     <span class="number">8</span> <span class="operator">|</span>                 <span class="number">10</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------+--------------------+</span></span><br></pre></td></tr></table></figure>
<p>生成的列的定义具有以下语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `table_name` <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> `col_name` datatype [GENRATED ALWAYS] <span class="keyword">AS</span> (expr) [VIRTUAL <span class="operator">|</span> STORED] [<span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>] [<span class="keyword">UNIQUE</span> [KEY]] [[<span class="keyword">PRIMARY</span>] KEY]</span><br><span class="line">[COMMENT <span class="string">&#x27;string&#x27;</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>AS (expr)表示生成列并定义用于计算列值的表达式。AS 之前可能有 GENRATED ALWAYS,以使列的生成性质更加明确。</li>
<li>VIRTUAL 或 STORED 关键字指示如何存储列值，如果未指定任何关键字，则默认值为 VIRTUAL.<ul>
<li>VIRTUAL：不存储列值，但在任何 BEFORE 触发后立即读取行时计算列值。虚拟列不占用存储空间。InnoDB 支持虚拟列上的二级索引。</li>
<li>STORED：插入或更新行时，将评估和存储列值。存储的列需要存储空间并且可以设置索引。</li>
</ul>
</li>
</ul>
<p>允许在表中混合 VIRTUAL 和 STORED 列。<br>生成的列表达式必须遵守以下规则。如果表达式不允许的构造，则会发生错误：</p>
<ul>
<li>允许使用文字，确定性内置函数和运算符。即要符合幂等。非确定函数的：CONNECTION_ID(), CURRENT_USER(), NOW()等。</li>
<li>不允许存储函数和用户自定义函数。</li>
<li>不允许存储过程和函数参数。</li>
<li>不允许使用变量。（系统变量，用户自定义的变量和存储的程序局部变量）。</li>
<li>不允许使用子查询。</li>
<li>生成的列定义可以引用其他生成的列，但只能用表定义中较早出现的列。生成的列定义可以引用表中的任何基本（非生成）列，无论其定义是早期还是稍后</li>
<li>AUTO_INCREMENT 属性不能在生成的列定义中使用。</li>
<li>AUTO_INCREMENT 列不能用作生成的列定义中的基本列。</li>
</ul>
<p>存储的生成列上的外键约束不能使用 ON UPDATE CASCADE, ON DELETE SET NULL, ON UPDATE SET NULL, ON DELETE SET DEFAULT 或 ON UPDATE SET DEFAULT。<br>外键约束不能引用虚拟生成的列。<br>生成的列有几个用例，例如：</p>
<ul>
<li>虚拟生成列可用作简化和统一查询的方法。一个复杂的条件可以定义为生成的列，并从表上的多个查询引用，以确保它们都使用完全相同的条件</li>
<li>存储生成列可用作物化缓存，用于复杂条件，这些条件在运行中计算成本很高。</li>
<li>生成的列可以模拟功能索引：使用生成的列定义功能表达式并对其进行索引。这对处理无法直接索引的类型列非常有用</li>
<li>对于存储的生成列，这种方法的缺点是值存储两次；一次作为生成列的值，一次作为索引</li>
</ul>
]]></content>
      <categories>
        <category>mySQL</category>
      </categories>
  </entry>
  <entry>
    <title>高性能MYSQL-读书笔记之索引(一)</title>
    <url>/2021/03/13/%E9%AB%98%E6%80%A7%E8%83%BDMYSQL-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%B4%A2%E5%BC%95-%E4%B8%80/</url>
    <content><![CDATA[<h3 id="索引基础"><a href="#索引基础" class="headerlink" title="索引基础"></a>索引基础</h3><h4 id="索引的类型"><a href="#索引的类型" class="headerlink" title="索引的类型"></a>索引的类型</h4><h5 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B-Tree索引"></a>B-Tree索引</h5><p>目前大部分数据库系统及文件系统都采用B-Tree或其变种B+Tree作为索引结构.<br>存储引擎以不同的方式使用B-Tree索引：</p>
<ul>
<li>MyISAM使用前缀压缩技术使得索引更小；MyISAM索引通过数据的无力位置引用被索引的行</li>
<li>InnoDB则按照原数据格式进行存储；InnoDB根据主键引用被索引的行</li>
</ul>
<p>可使用B-Tree索引的查询类型。B-Tree索引适用于全键值、键值范围或键前缀查找：</p>
<span id="more"></span>
<ul>
<li>全值匹配：和索引种的所有列进行匹配</li>
<li>匹配最左前缀：使用索引的第一列</li>
<li>匹配列前缀：匹配某一列的值的开头部分</li>
<li>匹配范围值：</li>
<li>精确匹配某一列并范围匹配另外一列</li>
<li>只访问索引的查询</li>
</ul>
<p>因为索引树中的结点是有序的，所以索引除了查找之外，还可以用于查询种的 ORDER BY 操作。只要 ORDER BY 子句满足以上的查询类型，则这个索引也可以满足排序需求</p>
<p>关于B-Tree索引的限制：</p>
<ul>
<li>如果不是按照索引的最左列开始查找，则无法使用索引</li>
<li>不能跳过索引中的列</li>
<li>如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找</li>
</ul>
<h4 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h4><p>哈希索引(hash index)基于哈希表实现，只有精确匹配索引所有列的查询才有效。<br>哈希索引的缺点：</p>
<ul>
<li>哈希索引只包含哈希值和行指针，不存储字段值，导致不能使用索引中的值来避免读取行</li>
<li>哈希索引数据并不是按照索引值顺序存储的，无法用于排序</li>
<li>哈希表不支持部分索引列匹配查找，因为哈希索引始终使用索引列的全部内容来计算哈希值的。例如，在数据列（A，B）上建立哈希索引，如果只查询A列，则无法使用索引</li>
<li>哈希只支持等值比较查询，包括=、IN()、&gt;、&lt;,不支持任何范围查询</li>
<li>如果哈希冲突很多，索引维护的代价会很高</li>
</ul>
<h4 id="空间数据索引"><a href="#空间数据索引" class="headerlink" title="空间数据索引"></a>空间数据索引</h4><h5 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h5><p>索引的优点<br>总结三个优点：</p>
<ul>
<li>1、索引大大减少了服务器需要扫描的数据量</li>
<li>2、索引可以帮助服务器避免排序和临时表</li>
<li>3、索引可以将随机I/O变为顺序I/O</li>
</ul>
]]></content>
      <categories>
        <category>mySQL</category>
      </categories>
  </entry>
  <entry>
    <title>高性能MYSQL-读书笔记之索引(二)</title>
    <url>/2021/03/14/%E9%AB%98%E6%80%A7%E8%83%BDMYSQL-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%B4%A2%E5%BC%95-%E4%BA%8C/</url>
    <content><![CDATA[<h3 id="高性能索引策略"><a href="#高性能索引策略" class="headerlink" title="高性能索引策略"></a>高性能索引策略</h3><p>正确的创建和使用索引是实现高性能查询的基础。</p>
<h4 id="独立的列"><a href="#独立的列" class="headerlink" title="独立的列"></a>独立的列</h4><p>“独立的列”是指索引列不能是表达式的一部分，也不能是函数的参数。举个例子：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">## 下面这个查询无法使用actor_id列的索引</span><br><span class="line"><span class="keyword">SELECT</span> actor_id <span class="keyword">FROM</span> sakila.actor <span class="keyword">WHERE</span> actor_id <span class="operator">+</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<h4 id="前缀索引和索引选择性"><a href="#前缀索引和索引选择性" class="headerlink" title="前缀索引和索引选择性"></a>前缀索引和索引选择性</h4><p>当需要索引很长的字符列时，会让索引变得大且慢。<span id="more"></span>通常可以索引开始的部分字符，可以减少索引空间，提高索引效率。但这样操作会降低索引的选择性。索引的选择性是指，不重复的索引值和数据表的记录总数(#T)的比值，范围在 1/#T到1之间。索引的选择性越高则查询效率越高。对于 BLOB、TEXT或很长的VARCHAR类型的列，必须使用前缀索引，因为MYSQL不允许这些列的完整长度。在使用前缀索引时，要选择足够长的前缀以保证较高的选择性，同时又不能太长。如何确定呢？举个例子:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">LEFT</span>(city, <span class="number">3</span>)) <span class="operator">/</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> sel3 <span class="keyword">FROM</span> sakila.city_demo;       ## <span class="number">0.0239</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">LEFT</span>(city, <span class="number">4</span>)) <span class="operator">/</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> sel4 <span class="keyword">FROM</span> sakila.city_demo;       ## <span class="number">0.0293</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">LEFT</span>(city, <span class="number">5</span>)) <span class="operator">/</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> sel5 <span class="keyword">FROM</span> sakila.city_demo;       ## <span class="number">0.0305</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">LEFT</span>(city, <span class="number">6</span>)) <span class="operator">/</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> sel6 <span class="keyword">FROM</span> sakila.city_demo;       ## <span class="number">0.0309</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">LEFT</span>(city, <span class="number">7</span>)) <span class="operator">/</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> sel7 <span class="keyword">FROM</span> sakila.city_demo;       ## <span class="number">0.0310</span> 查询显示长度为<span class="number">7</span>时，最接近</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> city) <span class="operator">/</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> selAll <span class="keyword">FROM</span> sakila.city_demo;   ## <span class="number">0.0312</span></span><br><span class="line">## 只看平均选择性是不够的，需要考虑最坏情况下的选择性</span><br></pre></td></tr></table></figure>
<p>当找到合适的前缀长度，就要创建前缀索引列，如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> sakila.city_demo <span class="keyword">ADD</span> KEY(city(<span class="number">7</span>));</span><br></pre></td></tr></table></figure>
<p>前缀索引需要注意的是MYSQL无法使用前缀索引做 ORDER BY 和 GROUP BY，也无法使用前缀索引做覆盖扫描。</p>
<h4 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h4><p>在多个列上建立独立的单列索引大部分情况下并不能提高MYSQL的查询性能。索引合并策略有时候是一种优化的结果，但实际上更多时候说明了表上的索引建的很糟糕。</p>
<h4 id="选择合适的索引列顺序"><a href="#选择合适的索引列顺序" class="headerlink" title="选择合适的索引列顺序"></a>选择合适的索引列顺序</h4><h4 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h4><p>聚簇索引并不是单独的索引类型，而是一种数据存储方式。当表有聚簇索引时，它的数据行实际存放在索引的叶子页(leaf page)中。一个表只能有一个聚簇索引。优点：</p>
<ul>
<li>可以把相关数据保存在一起</li>
<li>数据访问更快</li>
<li>使用覆盖索引扫描的查询可以直接使用页节点中的主键值。</li>
</ul>
<p>缺点：</p>
<ul>
<li>插入速度严重依赖插入顺序。如果不是按照主键顺序加载数据，那么加载完成后最好使用OPTIMIZE TABLE命令重新组织一下表</li>
<li>更新聚簇索引列的代价很高，因为会强制InnoDB将每个被更新的行移动到新的位置</li>
<li>基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临“页分裂(page split)”的问题。</li>
<li>聚簇索引可能导致全表扫描变慢</li>
<li>二级索引(非聚簇索引)可能比想象的更大，因为在二级索引的叶子结点包含了引用行的主键列</li>
<li>二级索引访问需要两次索引查找</li>
</ul>
<h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>如果一个索引包含或者说覆盖所有需要查询的字段的值，就是“覆盖索引”。覆盖索引的优点：</p>
<ul>
<li>索引条目通常远小于数据行大小</li>
<li>如果二级主键能够覆盖查询，则可以避免对主键索引的二次查询。覆盖索引必须要存储索引列的值，而哈希索引、空间索引、全文索引等都不存储，所以只能使用B-Tree索引做覆盖索引。</li>
</ul>
<h4 id="使用索引扫描来做排序"><a href="#使用索引扫描来做排序" class="headerlink" title="使用索引扫描来做排序"></a>使用索引扫描来做排序</h4><p>MySQL有两种方式可以生成有序的结果：</p>
<ul>
<li>通过排序操作</li>
<li>按索引顺序扫描。如果EXPLAIN出来的type列的值为“index”，则说明使用了索引扫描做排序</li>
</ul>
<p>满足索引做排序的条件如下：</p>
<ul>
<li>只有当索引的列顺序和ORDER BY子句的顺序完全一致，且所有的列的排序方向都一样时，MySQL才能使用索引对结果排序。</li>
<li>如果需要联表查询，则只有当ORDER BY子句引用的字段全部为第一个表时，才能使用索引做排序。</li>
<li>ORDER BY子句和查询的限制一样：需要满足索引的最左前缀要求<br>示例：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">## rental表中有以下索引：</span><br><span class="line">## <span class="keyword">UNIQUE</span> KEY rental_date(rental_date, inventory_id, customer_id)</span><br><span class="line">## key idx_fk_inventory_id(inventory_id)</span><br><span class="line">## key_idx_fk_customer_id(customer_id)</span><br><span class="line">## key_idx_fk_staff_id(staff_id)</span><br><span class="line">## 这个查询可以利用索引排序，因为索引的第一列提供了常量条件,而使用第二列排序，将两列组合，就符合索引的最左前缀</span><br><span class="line"><span class="keyword">SELECT</span> rental_id, staff_id <span class="keyword">FROM</span> sakila.rental <span class="keyword">WHERE</span> rental_date <span class="operator">=</span> <span class="string">&#x27;2019-03-31&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> inventory_id <span class="keyword">DESC</span>;</span><br><span class="line"></span><br><span class="line">## 这个也可以索引排序,因为<span class="keyword">ORDER</span> <span class="keyword">BY</span> 使用的两列就是索引的最左前缀</span><br><span class="line"><span class="keyword">SELECT</span> rental_id, staff_id <span class="keyword">FROM</span> sakila.rental <span class="keyword">WHERE</span> rental_date <span class="operator">&lt;</span> <span class="string">&#x27;2019-03-31&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> rental_date, inventory_id;</span><br><span class="line"></span><br><span class="line">## 下面是一些不能使用索引做排序的查询</span><br><span class="line">## 这个查询使用了两种不同的排序方向，但索引列都是正序排序的</span><br><span class="line"><span class="keyword">SELECT</span> rental_id, staff_id <span class="keyword">FROM</span> sakila.rental <span class="keyword">WHERE</span> rental_date <span class="operator">=</span> <span class="string">&#x27;2019-03-31&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> inventory_id <span class="keyword">DESC</span>, customer_id <span class="keyword">ASC</span>;</span><br><span class="line">## 这个查询的<span class="keyword">ORDER</span> <span class="keyword">BY</span> 子句中引用了一个不在索引中的列</span><br><span class="line"><span class="keyword">SELECT</span> rental_id, staff_id <span class="keyword">FROM</span> sakila.rental <span class="keyword">WHERE</span> rental_date <span class="operator">=</span> <span class="string">&#x27;2019-03-31&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> inventory_id, staff_id;</span><br><span class="line">## 这个查询的<span class="keyword">WHERE</span>和<span class="keyword">ORDER</span> <span class="keyword">BY</span>中的列无法组合成索引的最左前缀</span><br><span class="line"><span class="keyword">SELECT</span> rental_id, staff_id <span class="keyword">FROM</span> sakila.rental <span class="keyword">WHERE</span> rental_date <span class="operator">=</span> <span class="string">&#x27;2019-03-31&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> customer_id;</span><br><span class="line">##  这个查询在索引列的第一列上是范围条件，所以无法使用索引的其余列</span><br><span class="line"><span class="keyword">SELECT</span> rental_id, staff_id <span class="keyword">FROM</span> sakila.rental <span class="keyword">WHERE</span> rental_date <span class="operator">&gt;</span> <span class="string">&#x27;2019-03-31&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> inventory_id, customer_id;</span><br><span class="line">## 这个查询在inventory_id列上有多个等于条件。对于排序来说，这也是一种范围查询</span><br><span class="line"><span class="keyword">SELECT</span> rental_id, staff_id <span class="keyword">FROM</span> sakila.rental <span class="keyword">WHERE</span> rental_date <span class="operator">=</span> <span class="string">&#x27;2019-03-31&#x27;</span> <span class="keyword">AND</span> inventory_id <span class="keyword">IN</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="keyword">ORDER</span> <span class="keyword">BY</span> customer_id;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="冗余和重复的索引"><a href="#冗余和重复的索引" class="headerlink" title="冗余和重复的索引"></a>冗余和重复的索引</h4><p>重复索引是指在相同的列上按照相同的顺序创建相同类型的索引。应该避免重复索引。冗余索引和重复索引有一些不同。例如：</p>
<ul>
<li>创建了索引(A, B)，在创建索引(A)就是冗余索引，因为这只是前一个索引的前缀索引</li>
<li>创建了索引(A, B)，在创建索引(B, A)，则不是冗余索引，索引(B)也不是</li>
</ul>
]]></content>
      <categories>
        <category>mySQL</category>
      </categories>
  </entry>
  <entry>
    <title>GO语言基础-day01</title>
    <url>/2021/03/22/GO%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-day01/</url>
    <content><![CDATA[<h3 id="1、GO的执行原理"><a href="#1、GO的执行原理" class="headerlink" title="1、GO的执行原理"></a>1、GO的执行原理</h3><p><img src="http://free-cn-01.oss.tusy.xyz/asf/jfs/t1/157815/21/15246/134300/6058acb5E3838c238/2a16ca8950783f07.png" alt="GO的源码文件分类"><br>如上图分为三类：</p>
<span id="more"></span>
<ul>
<li>1、命令源码文件<ul>
<li>1、声明自己属于 main 代码包、包含无参数声明和结果声明的 main 函数。</li>
<li>2、命令源码文件被安装以后，GOPATH 如果只有一个工作区，那么相应的可执行文件会被存放当前工作区的 bin 文件夹下；如果有多个工作区，就会安装到 GOBIN 指向的目录下。</li>
<li>3、命令源码文件是 Go 程序的入口。</li>
<li>4、同一个代码包中最好也不要放多个命令源码文件。多个命令源码文件虽然可以分开单独 go run 运行起来，但是无法通过 go build 和 go install。</li>
</ul>
</li>
<li>2、库源码文件<ul>
<li>1、库源码文件就是不具备命令源码文件上述两个特征的源码文件。存在于某个代码包中的普通的源码文件。</li>
<li>2、库源码文件被安装后，相应的归档文件（.a 文件）会被存放到当前工作区的 pkg 的平台相关目录下。</li>
</ul>
</li>
<li>3、测试源码文件<ul>
<li>1、名称以 _test.go 为后缀的代码文件，并且必须包含 Test 或者 Benchmark 名称前缀的函数：</li>
<li>2、<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 名称以 Test 为名称前缀的函数，只能接受 *testing.T 的参数，这种测试函数是功能测试函数。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestXXX</span><span class="params">( t *testing.T)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 名称以 Benchmark 为名称前缀的函数，只能接受 *testing.B 的参数，这种测试函数是性能测试函数。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkXXX</span><span class="params">( b *testing.B)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="2、GO的命令"><a href="#2、GO的命令" class="headerlink" title="2、GO的命令"></a>2、GO的命令</h3><p>截至V1.12里面基本命令有以下17个。<br>我们可以打开终端输入：go help即可看到Go的这些命令以及简介。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">bug         start a bug report</span><br><span class="line">build       compile packages and dependencies</span><br><span class="line">clean       remove object files and cached files</span><br><span class="line">doc         show documentation for package or symbol</span><br><span class="line">env         print Go environment information</span><br><span class="line">fix         update packages to use new APIs</span><br><span class="line">fmt         gofmt (reformat) package sources</span><br><span class="line">generate    generate Go files by processing source</span><br><span class="line">get         download and install packages and dependencies</span><br><span class="line">install     compile and install packages and dependencies</span><br><span class="line">list        list packages or modules</span><br><span class="line">mod         module maintenance</span><br><span class="line">run         compile and run Go program</span><br><span class="line">test        test packages</span><br><span class="line">tool        run specified go tool</span><br><span class="line">version     print Go version</span><br><span class="line">vet         report likely mistakes in packages</span><br></pre></td></tr></table></figure>
<p>其中和编译相关的有build、get、install、run这4个。接下来就依次看看这四个的作用。<br>在详细分析这4个命令之前，先罗列一下通用的命令标记，以下这些命令都可适用的：<br>|   名称   |   说明   |<br>| —- | —- |<br>|  -a  |   用于强制重新编译所有涉及的 Go 语言代码包（包括 Go 语言标准库中的代码包），即使它们已经是最新的了。该标记可以让我们有机会通过改动底层的代码包做一些实验。   |<br>|  -n  |  使命令仅打印其执行过程中用到的所有命令，而不去真正执行它们。如果不只想查看或者验证命令的执行过程，而不想改变任何东西，使用它正好合适。    |<br>| -race  |  用于检测并报告指定 Go 语言程序中存在的数据竞争问题。当用 Go 语言编写并发程序的时候，这是很重要的检测手段之一。    |<br>| -v   |   用于打印命令执行过程中涉及的代码包。这一定包括我们指定的目标代码包，并且有时还会包括该代码包直接或间接依赖的那些代码包。这会让你知道哪些代码包被执行过了。   |<br>| -work   |   用于打印命令执行时生成和使用的临时工作目录的名字，且命令执行完成后不删除它。这个目录下的文件可能会对你有用，也可以从侧面了解命令的执行过程。如果不添加此标记，那么临时工作目录会在命令执行完毕前删除。   |<br>|  -x    |   使命令打印其执行过程中用到的所有命令，并同时执行它们。   |</p>
<h5 id="2-1、go-run"><a href="#2-1、go-run" class="headerlink" title="2.1、go run"></a>2.1、go run</h5><p>专门用来运行命令源码文件的命令，注意，这个命令不是用来运行所有 Go 的源码文件的！<br>go run 命令只能接受一个命令源码文件以及若干个库源码文件（必须同属于 main 包）作为文件参数，且不能接受测试源码文件。它在执行时会检查源码文件的类型。如果参数中有多个或者没有命令源码文件，那么 go run 命令就只会打印错误提示信息并退出，而不会继续执行。<br><img src="http://free-cn-01.cdn.bilnn.com/ddfilesass/jfs/t1/156225/37/17963/50322/605bd9f9E4a81f0e3/e25206db86f5ac21.jpg" alt="go run执行过程"><br>go run 命令在第二次执行的时候，如果发现导入的代码包没有发生变化，那么 go run 不会再次编译这个导入的代码包。直接静态链接进来。</p>
<h5 id="2-2、go-build"><a href="#2-2、go-build" class="headerlink" title="2.2、go build"></a>2.2、go build</h5><p>go build 命令主要是用于测试编译。在包的编译过程中，若有必要，会同时编译与之相关联的包。</p>
<ul>
<li>1、如果是普通包，当你执行go build命令后，不会产生任何文件。</li>
<li>2、如果是main包，当只执行go build命令后，会在当前目录下生成一个可执行文件。如果需要在$GOPATH/bin目录下生成相应的exe文件，需要执行go install 或者使用 go build -o 路径/可执行文件。</li>
<li>3、如果某个文件夹下有多个文件，而你只想编译其中某一个文件，可以在 go build 之后加上文件名，例如 go build a.go；go build 命令默认会编译当前目录下的所有go文件。</li>
<li>4、你也可以指定编译输出的文件名。比如，我们可以指定go build -o 可执行文件名，默认情况是你的package名(非main包)，或者是第一个源文件的文件名(main包)。</li>
<li>5、go build 会忽略目录下以”_”或者”.”开头的go文件。</li>
<li>6、如果你的源代码针对不同的操作系统需要不同的处理，那么你可以根据不同的操作系统后缀来命名文件。</li>
</ul>
<p>当代码包中有且仅有一个命令源码文件的时候，在文件夹所在目录中执行 go build 命令，会在该目录下生成一个与目录同名的可执行文件。</p>
<p><img src="http://free-cn-01.cdn.bilnn.com/ddfilesass/jfs/t1/174535/2/269/132299/605bdb5bE4356d523/c1365aefd78680ba.png" alt="执行区别"></p>
<h5 id="2-3、go-install"><a href="#2-3、go-install" class="headerlink" title="2.3、go install"></a>2.3、go install</h5><h5 id="2-4、go-get"><a href="#2-4、go-get" class="headerlink" title="2.4、go get"></a>2.4、go get</h5>]]></content>
      <categories>
        <category>GO基础</category>
      </categories>
      <tags>
        <tag>GO</tag>
      </tags>
  </entry>
  <entry>
    <title>GO基础语法-day02</title>
    <url>/2021/03/25/GO%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95-day02/</url>
    <content><![CDATA[<h3 id="1、变量的使用"><a href="#1、变量的使用" class="headerlink" title="1、变量的使用"></a>1、变量的使用</h3><h4 id="1-1、声明变量"><a href="#1-1、声明变量" class="headerlink" title="1.1、声明变量"></a>1.1、声明变量</h4><p>以字母或下划线开头，由一个或多个字母、数字、下划线组成</p>
<h5 id="1-1-1、声明一个变量"><a href="#1-1-1、声明一个变量" class="headerlink" title="1.1.1、声明一个变量"></a>1.1.1、声明一个变量</h5><p>第一种，指定变量类型，声明后若不赋值，使用默认值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="keyword">type</span></span><br><span class="line">name = <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>第二种，根据值自行判定变量类型(类型推断Type inference)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>第三种，省略var, 注意 :=左侧的变量不应该是已经声明过的(多个变量同时声明时，至少保证一个是新变量)，否则会导致编译错误(简短声明)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">name := <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例如</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">10</span></span><br><span class="line">c : = <span class="number">10</span></span><br></pre></td></tr></table></figure>

<h5 id="1-1-2、多变量声明"><a href="#1-1-2、多变量声明" class="headerlink" title="1.1.2、多变量声明"></a>1.1.2、多变量声明</h5><p>第一种，以逗号分隔，声明与赋值分开，若不赋值，存在默认值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name1, name2, name3 <span class="keyword">type</span></span><br><span class="line">name1, name2, name3 = v1, v2, v3</span><br></pre></td></tr></table></figure>

<p>第二种，直接赋值，下面的变量类型可以是不同的类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name1, name2, name3 = v1, v2, v3</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第三种，集合类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    name1 type1</span><br><span class="line">    name2 type2</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="1-2、注意事项"><a href="#1-2、注意事项" class="headerlink" title="1.2、注意事项"></a>1.2、注意事项</h4><ul>
<li>1、变量必须先定义才能使用</li>
<li>2、go语言是静态语言，要求变量的类型和赋值的类型必须一致。</li>
<li>3、变量名不能冲突。(同一个作用于域内不能冲突)</li>
<li>4、简短定义方式，左边的变量名至少有一个是新的</li>
<li>5、简短定义方式，不能定义全局变量。</li>
<li>6、变量的零值。也叫默认值。</li>
<li>7、变量定义了就要使用，否则无法通过编译。</li>
</ul>
<h3 id="2、常量的使用"><a href="#2、常量的使用" class="headerlink" title="2、常量的使用"></a>2、常量的使用</h3><p>常量是一个简单值的标识符，在程序运行时，不会被修改的量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> identifier [<span class="keyword">type</span>] = value</span><br><span class="line">显式类型定义： <span class="keyword">const</span> b <span class="keyword">string</span> = <span class="string">&quot;abc&quot;</span></span><br><span class="line">隐式类型定义： <span class="keyword">const</span> b = <span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">const</span> LENGTH <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">   <span class="keyword">const</span> WIDTH <span class="keyword">int</span> = <span class="number">5</span>   </span><br><span class="line">   <span class="keyword">var</span> area <span class="keyword">int</span></span><br><span class="line">   <span class="keyword">const</span> a, b, c = <span class="number">1</span>, <span class="literal">false</span>, <span class="string">&quot;str&quot;</span> <span class="comment">//多重赋值</span></span><br><span class="line"></span><br><span class="line">   area = LENGTH * WIDTH</span><br><span class="line">   fmt.Printf(<span class="string">&quot;面积为 : %d&quot;</span>, area)</span><br><span class="line">   <span class="built_in">println</span>()</span><br><span class="line">   <span class="built_in">println</span>(a, b, c)   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>常量可以作为枚举，常量组</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Unknown = <span class="number">0</span></span><br><span class="line">    Female = <span class="number">1</span></span><br><span class="line">    Male = <span class="number">2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>常量组中如不指定类型和初始化值，则与上一行非空常量右值相同</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> (</span><br><span class="line">        x <span class="keyword">uint16</span> = <span class="number">16</span></span><br><span class="line">        y</span><br><span class="line">        s = <span class="string">&quot;abc&quot;</span></span><br><span class="line">        z</span><br><span class="line">    )</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%T,%v\n&quot;</span>, y, y)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%T,%v\n&quot;</span>, z, z)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint16</span>,<span class="number">16</span></span><br><span class="line"><span class="keyword">string</span>,abc</span><br></pre></td></tr></table></figure>
<h4 id="2-1、常量注意事项"><a href="#2-1、常量注意事项" class="headerlink" title="2.1、常量注意事项"></a>2.1、常量注意事项</h4><ul>
<li>1、常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型</li>
<li>2、不曾使用的常量，在编译的时候，是不会报错的</li>
<li>3、显示指定类型的时候，必须确保常量左右值类型一致，需要时可做显示类型转换。这与变量就不一样了，变量是可以是不同的类型值</li>
</ul>
<h4 id="2-2、iota"><a href="#2-2、iota" class="headerlink" title="2.2、iota"></a>2.2、iota</h4><p>iota，特殊常量，可以认为是一个可以被编译器修改的常量<br>iota 可以被用作枚举值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a = <span class="literal">iota</span></span><br><span class="line">    b = <span class="literal">iota</span></span><br><span class="line">    c = <span class="literal">iota</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个 iota 等于 0，每当 iota 在新的一行被使用时，它的值都会自动加 1；所以 a=0, b=1, c=2 可以简写为如下形式：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a = <span class="literal">iota</span></span><br><span class="line">    b</span><br><span class="line">    c</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>iota用法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> (</span><br><span class="line">            a = <span class="literal">iota</span>   <span class="comment">//0</span></span><br><span class="line">            b          <span class="comment">//1</span></span><br><span class="line">            c          <span class="comment">//2</span></span><br><span class="line">            d = <span class="string">&quot;ha&quot;</span>   <span class="comment">//独立值，iota += 1</span></span><br><span class="line">            e          <span class="comment">//&quot;ha&quot;   iota += 1</span></span><br><span class="line">            f = <span class="number">100</span>    <span class="comment">//iota +=1</span></span><br><span class="line">            g          <span class="comment">//100  iota +=1</span></span><br><span class="line">            h = <span class="literal">iota</span>   <span class="comment">//7,恢复计数</span></span><br><span class="line">            i          <span class="comment">//8</span></span><br><span class="line">    )</span><br><span class="line">    fmt.Println(a,b,c,d,e,f,g,h,i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果 0 1 2 ha ha 100 100 7 8</span></span><br></pre></td></tr></table></figure>
<p>如果中断iota自增，则必须显式恢复。且后续自增值按行序递增，自增默认是int类型，可以自行进行显示指定类型。数字常量不会分配存储空间，无须像变量那样通过内存寻址来取值，因此无法获取地址</p>
]]></content>
      <categories>
        <category>GO基础</category>
      </categories>
      <tags>
        <tag>GO</tag>
      </tags>
  </entry>
  <entry>
    <title>GO运算符-day03</title>
    <url>/2021/03/28/GO%E8%BF%90%E7%AE%97%E7%AC%A6-day03/</url>
    <content><![CDATA[<h3 id="1、运算符"><a href="#1、运算符" class="headerlink" title="1、运算符"></a>1、运算符</h3><h4 id="1-1、算术运算符"><a href="#1-1、算术运算符" class="headerlink" title="1.1、算术运算符"></a>1.1、算术运算符</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">+ - * / %(求余) ++ --</span><br></pre></td></tr></table></figure>

<h4 id="1-2、关系运算符"><a href="#1-2、关系运算符" class="headerlink" title="1.2、关系运算符"></a>1.2、关系运算符</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">== != &gt; &lt; &gt;= &lt;=</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1-3、逻辑运算符"><a href="#1-3、逻辑运算符" class="headerlink" title="1.3、逻辑运算符"></a>1.3、逻辑运算符</h4><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;&amp;</td>
<td>逻辑与运算符。如果两个操作数都非零，则条件变为真</td>
</tr>
<tr>
<td>||</td>
<td>逻辑或操作。如果任何两个操作数是非零，则条件变为真</td>
</tr>
<tr>
<td>!</td>
<td>逻辑非运算符。使用反转操作数的逻辑状态。如果条件为真，那么逻辑非操后结果为假</td>
</tr>
</tbody></table>
<span id="more"></span>
<h4 id="1-4、位运算符"><a href="#1-4、位运算符" class="headerlink" title="1.4、位运算符"></a>1.4、位运算符</h4><table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>A&amp;B</th>
<th>A|B</th>
<th>A^B</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
</tbody></table>
<p>举个例子，假设A = 60， B = 13<br>|   运算符   |   描述   |  示例    |<br>| —- | —- | —- |<br>|  &amp;    |  二进制与操作    | (A &amp; B) = 12, 也就是 0000 1100     |<br>|  |    |  二进制或操作    | (A | B) = 61, 也就是 0011 1101     |<br>|  ^    |  二进制异或操作，如果它被设置在一个操作数就是按位取非    |  (A ^ B) = 49, 也就是 0011 0001    |<br>|  &amp;^    | 二进制位清空     |   (A&amp;^B)=48，也就是110000   |<br>|  &lt;&lt;    |  二进制左移位    |   A &lt;&lt; 2 =240 也就是 1111 0000   |<br>|  &gt;&gt;    |  二进制右移位    |   A &gt;&gt; 2 = 15 也就是 0000 1111   |</p>
<h4 id="1-4、赋值运算符"><a href="#1-4、赋值运算符" class="headerlink" title="1.4、赋值运算符"></a>1.4、赋值运算符</h4><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>=</td>
<td>简单的赋值操作符，分配值从右边的操作数左侧的操作数</td>
<td>C = A + B 将分配A + B的值到C</td>
</tr>
<tr>
<td>+=</td>
<td>相加并赋值运算符，它增加了右操作数左操作数和分配结果左操作数</td>
<td>C += A 相当于 C = C + A</td>
</tr>
<tr>
<td>-=</td>
<td>减和赋值运算符，它减去右操作数从左侧的操作数和分配结果左操作数</td>
<td>C -= A 相当于 C = C - A</td>
</tr>
<tr>
<td>*=</td>
<td>乘法和赋值运算符，它乘以右边的操作数与左操作数和分配结果左操作数</td>
<td>C *= A 相当于 C = C * A</td>
</tr>
<tr>
<td>/=</td>
<td>除法赋值运算符，它把左操作数与右操作数和分配结果左操作数</td>
<td>C /= A 相当于 C = C / A</td>
</tr>
<tr>
<td>%=</td>
<td>模量和赋值运算符，它需要使用两个操作数的模量和分配结果左操作数</td>
<td>C %= A 相当于 C = C % A</td>
</tr>
<tr>
<td>&lt;&lt;=</td>
<td>左移位并赋值运算符</td>
<td>C &lt;&lt;= 2 相同于 C = C &lt;&lt; 2</td>
</tr>
<tr>
<td>&gt;&gt;=</td>
<td>向右移位并赋值运算符</td>
<td>C &gt;&gt;= 2 相同于 C = C &gt;&gt; 2</td>
</tr>
<tr>
<td>&amp;=</td>
<td>按位与赋值运算符</td>
<td>C &amp;= 2 相同于 C = C &amp; 2</td>
</tr>
<tr>
<td>^=</td>
<td>按位异或并赋值运算符</td>
<td>C ^= 2 相同于 C = C ^ 2</td>
</tr>
<tr>
<td>|=</td>
<td>按位或并赋值运算符</td>
<td>C |= 2 相同于 C = C | 2</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>GO基础</category>
      </categories>
      <tags>
        <tag>GO</tag>
      </tags>
  </entry>
  <entry>
    <title>GO数组-day04</title>
    <url>/2021/03/29/GO%E6%95%B0%E7%BB%84-day04/</url>
    <content><![CDATA[<h3 id="1、数组"><a href="#1、数组" class="headerlink" title="1、数组"></a>1、数组</h3><h4 id="1-1、声明和初始化数组"><a href="#1-1、声明和初始化数组" class="headerlink" title="1.1、声明和初始化数组"></a>1.1、声明和初始化数组</h4><p>需要指明数组的大小和存储的数据类型。<span id="more"></span></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> variable_name [SIZE] variable_type</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> balance [<span class="number">10</span>] <span class="keyword">float32</span></span><br><span class="line"><span class="keyword">var</span> balance = [<span class="number">5</span>]<span class="keyword">float32</span>&#123;<span class="number">1000.0</span>, <span class="number">2.0</span>, <span class="number">3.4</span>, <span class="number">7.0</span>, <span class="number">50.0</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化数组中 &#123;&#125; 中的元素个数不能大于 [] 中的数字。 如果忽略 [] 中的数字不设置数组大小，Go 语言会根据元素的个数来设置数组的大小：</span></span><br><span class="line"><span class="keyword">var</span> balance = []<span class="keyword">float32</span>&#123;<span class="number">1000.0</span>, <span class="number">2.0</span>, <span class="number">3.4</span>, <span class="number">7.0</span>, <span class="number">50.0</span>&#125;</span><br><span class="line">balance[<span class="number">4</span>] = <span class="number">50.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组的其他创建方式</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> a [<span class="number">4</span>] <span class="keyword">float32</span> <span class="comment">// 等价于：var arr2 = [4]float32&#123;&#125;</span></span><br><span class="line">  fmt.Println(a) <span class="comment">// [0 0 0 0]</span></span><br><span class="line">  <span class="keyword">var</span> b = [<span class="number">5</span>] <span class="keyword">string</span>&#123;<span class="string">&quot;ruby&quot;</span>, <span class="string">&quot;王二狗&quot;</span>, <span class="string">&quot;rose&quot;</span>&#125;</span><br><span class="line">  fmt.Println(b) <span class="comment">// [ruby 王二狗 rose  ]</span></span><br><span class="line">  <span class="keyword">var</span> c = [<span class="number">5</span>] <span class="keyword">int</span>&#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>&#125; <span class="comment">// byte</span></span><br><span class="line">  fmt.Println(c) <span class="comment">// [65 66 67 68 69]</span></span><br><span class="line">  d := [...] <span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;<span class="comment">// 根据元素的个数，设置数组的大小</span></span><br><span class="line">  fmt.Println(d)<span class="comment">//[1 2 3 4 5]</span></span><br><span class="line">  e := [<span class="number">5</span>] <span class="keyword">int</span>&#123;<span class="number">4</span>: <span class="number">100</span>&#125; <span class="comment">// [0 0 0 0 100]</span></span><br><span class="line">  fmt.Println(e)</span><br><span class="line">  f := [...] <span class="keyword">int</span>&#123;<span class="number">0</span>: <span class="number">1</span>, <span class="number">4</span>: <span class="number">1</span>, <span class="number">9</span>: <span class="number">1</span>&#125; <span class="comment">// [1 0 0 0 1 0 0 0 0 1]</span></span><br><span class="line">  fmt.Println(f)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1-2、遍历数组"><a href="#1-2、遍历数组" class="headerlink" title="1.2、遍历数组"></a>1.2、遍历数组</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a := [...]<span class="keyword">float64</span>&#123;<span class="number">67.7</span>, <span class="number">89.8</span>, <span class="number">21</span>, <span class="number">78</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(a); i++ &#123; <span class="comment">//looping from 0 to the length of the array</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;%d th element of a is %.2f\n&quot;</span>, i, a[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// for...range遍历数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a := [...]<span class="keyword">float64</span>&#123;<span class="number">67.7</span>, <span class="number">89.8</span>, <span class="number">21</span>, <span class="number">78</span>&#125;</span><br><span class="line">    sum := <span class="keyword">float64</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> a &#123;<span class="comment">//range returns both the index and value</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;%d the element of a is %.2f\n&quot;</span>, i, v)</span><br><span class="line">        sum += v</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;\nsum of all elements of a&quot;</span>,sum)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果您只需要值并希望忽略索引，那么可以通过使用_ blank标识符替换索引来实现这一点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> a &#123; <span class="comment">//ignores index  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1-3、多维数组"><a href="#1-3、多维数组" class="headerlink" title="1.3、多维数组"></a>1.3、多维数组</h4><p>Go 语言支持多维数组，以下为常用的多维数组声明语法方式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> variable_name [SIZE1][SIZE2]...[SIZEN] variable_type</span><br><span class="line"><span class="keyword">var</span> threedim [<span class="number">5</span>][<span class="number">10</span>][<span class="number">4</span>]<span class="keyword">int</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1-4、数组是值类型"><a href="#1-4、数组是值类型" class="headerlink" title="1.4、数组是值类型"></a>1.4、数组是值类型</h4><p>Go中的数组是值类型，而不是引用类型。这意味着当它们被分配给一个新变量时，将把原始数组的副本分配给新变量。如果对新变量进行了更改，则不会在原始数组中反映</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a := [...]<span class="keyword">string</span>&#123;<span class="string">&quot;USA&quot;</span>, <span class="string">&quot;China&quot;</span>, <span class="string">&quot;India&quot;</span>, <span class="string">&quot;Germany&quot;</span>, <span class="string">&quot;France&quot;</span>&#125;</span><br><span class="line">    b := a <span class="comment">// a copy of a is assigned to b</span></span><br><span class="line">    b[<span class="number">0</span>] = <span class="string">&quot;Singapore&quot;</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;a is &quot;</span>, a)</span><br><span class="line">    fmt.Println(<span class="string">&quot;b is &quot;</span>, b) </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a is [USA China India Germany France] </span></span><br><span class="line"><span class="comment">// b is [Singapore China India Germany France] </span></span><br></pre></td></tr></table></figure>
<p>数组的大小是类型的一部分。因此[5]int和[25]int是不同的类型。因此，数组不能被调整大小。不要担心这个限制，因为切片的存在是为了解决这个问题。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">5</span>, <span class="number">78</span>, <span class="number">8</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> b [<span class="number">5</span>]<span class="keyword">int</span></span><br><span class="line">    b = a <span class="comment">//not possible since [3]int and [5]int are distinct types</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>GO基础</category>
      </categories>
      <tags>
        <tag>GO</tag>
      </tags>
  </entry>
  <entry>
    <title>GO切片-day05</title>
    <url>/2021/03/29/GO%E5%88%87%E7%89%87-day05/</url>
    <content><![CDATA[<h3 id="1、什么是切片"><a href="#1、什么是切片" class="headerlink" title="1、什么是切片"></a>1、什么是切片</h3><p>切片是一种数据结构。是一个很小的对象，对底层数组进行了抽象，并提供相关的操作方法。<br>从概念上面来说slice像一个结构体，这个结构体包含了三个字段：</p>
<ul>
<li>1、指向底层数组的指针，指向数组中slice指定的开始位置</li>
<li>2、长度，即slice的长度，切片访问的元素的个数</li>
<li>3、最大长度，也就是slice开始位置到数组的最后位置的长度，即容量<span id="more"></span></li>
</ul>
<h3 id="2、创建和初始化"><a href="#2、创建和初始化" class="headerlink" title="2、创建和初始化"></a>2、创建和初始化</h3><h4 id="2-1、make和切片字面量"><a href="#2-1、make和切片字面量" class="headerlink" title="2.1、make和切片字面量"></a>2.1、make和切片字面量</h4><p>使用内置的make函数创建切片，示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// c创建一个字符串切片，长度和容量都是5</span></span><br><span class="line">slice := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果只指定长度，那切片的容量和长度相等。也可以分别指定长度和容量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个整型切片，长度为3，容量为5</span></span><br><span class="line">slice := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过字面量来声明切片</span></span><br><span class="line"><span class="comment">// 创建字符串切片</span></span><br><span class="line">slice := []<span class="keyword">string</span>&#123;<span class="string">&quot;red&quot;</span>, <span class="string">&quot;Blue&quot;</span>, <span class="string">&quot;Green&quot;</span>, <span class="string">&quot;Yellow&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2、nil和空切片"><a href="#2-2、nil和空切片" class="headerlink" title="2.2、nil和空切片"></a>2.2、nil和空切片</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建nil整型切片</span></span><br><span class="line"><span class="keyword">var</span> slice []<span class="keyword">int</span></span><br></pre></td></tr></table></figure>
<p>在Go语言里，nil切片是很常见的创建切片的方法。nil切片可用于很多标准库和内置函数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明空切片</span></span><br><span class="line">slice := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">slice := []<span class="keyword">int</span>&#123;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>GO基础</category>
      </categories>
      <tags>
        <tag>GO</tag>
      </tags>
  </entry>
</search>
