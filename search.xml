<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>mysql 5.7虚拟列 generated columns</title>
    <url>/2021/03/14/mysql-5-7%E8%99%9A%E6%8B%9F%E5%88%97-generated-columns/</url>
    <content><![CDATA[<h3 id="CREATE-TABLE-支持生成的列"><a href="#CREATE-TABLE-支持生成的列" class="headerlink" title="CREATE TABLE 支持生成的列"></a>CREATE TABLE 支持生成的列</h3><p>生成列的值是根据列定义中包含的表达式计算的。<br>下面的简单示例的表，该表存储了 sidea 和 sideb 列中直角三角形的长度，并计算了sidec 中斜边的长度:<span id="more"></span></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> triangle(</span><br><span class="line">    sidea <span class="keyword">DOUBLE</span>,</span><br><span class="line">    sideb <span class="keyword">DOUBLE</span>,</span><br><span class="line">    sidec <span class="keyword">DOUBLE</span> <span class="keyword">AS</span> (<span class="built_in">SQRT</span>(sidea <span class="operator">*</span> sidea <span class="operator">+</span> sideb <span class="operator">*</span> sideb))</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> triangle (sidea, sideb) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">1</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">6</span>, <span class="number">8</span>);</span><br></pre></td></tr></table></figure>
<p>从表中选择会产生以下结果,使用 triangle 表的任何应用程序都可以访问斜边值，而无需指定计算它们的表达式。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> triangle;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------+--------------------+</span></span><br><span class="line"><span class="operator">|</span> sidea <span class="operator">|</span> sideb <span class="operator">|</span> sidec              <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------+--------------------+</span></span><br><span class="line"><span class="operator">|</span>     <span class="number">1</span> <span class="operator">|</span>     <span class="number">1</span> <span class="operator">|</span> <span class="number">1.4142135623730951</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>     <span class="number">3</span> <span class="operator">|</span>     <span class="number">4</span> <span class="operator">|</span>                  <span class="number">5</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>     <span class="number">6</span> <span class="operator">|</span>     <span class="number">8</span> <span class="operator">|</span>                 <span class="number">10</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------+--------------------+</span></span><br></pre></td></tr></table></figure>
<p>生成的列的定义具有以下语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `table_name` <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> `col_name` datatype [GENRATED ALWAYS] <span class="keyword">AS</span> (expr) [VIRTUAL <span class="operator">|</span> STORED] [<span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>] [<span class="keyword">UNIQUE</span> [KEY]] [[<span class="keyword">PRIMARY</span>] KEY]</span><br><span class="line">[COMMENT <span class="string">&#x27;string&#x27;</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>AS (expr)表示生成列并定义用于计算列值的表达式。AS 之前可能有 GENRATED ALWAYS,以使列的生成性质更加明确。</li>
<li>VIRTUAL 或 STORED 关键字指示如何存储列值，如果未指定任何关键字，则默认值为 VIRTUAL.<ul>
<li>VIRTUAL：不存储列值，但在任何 BEFORE 触发后立即读取行时计算列值。虚拟列不占用存储空间。InnoDB 支持虚拟列上的二级索引。</li>
<li>STORED：插入或更新行时，将评估和存储列值。存储的列需要存储空间并且可以设置索引。</li>
</ul>
</li>
</ul>
<p>允许在表中混合 VIRTUAL 和 STORED 列。<br>生成的列表达式必须遵守以下规则。如果表达式不允许的构造，则会发生错误：</p>
<ul>
<li>允许使用文字，确定性内置函数和运算符。即要符合幂等。非确定函数的：CONNECTION_ID(), CURRENT_USER(), NOW()等。</li>
<li>不允许存储函数和用户自定义函数。</li>
<li>不允许存储过程和函数参数。</li>
<li>不允许使用变量。（系统变量，用户自定义的变量和存储的程序局部变量）。</li>
<li>不允许使用子查询。</li>
<li>生成的列定义可以引用其他生成的列，但只能用表定义中较早出现的列。生成的列定义可以引用表中的任何基本（非生成）列，无论其定义是早期还是稍后</li>
<li>AUTO_INCREMENT 属性不能在生成的列定义中使用。</li>
<li>AUTO_INCREMENT 列不能用作生成的列定义中的基本列。</li>
</ul>
<p>存储的生成列上的外键约束不能使用 ON UPDATE CASCADE, ON DELETE SET NULL, ON UPDATE SET NULL, ON DELETE SET DEFAULT 或 ON UPDATE SET DEFAULT。<br>外键约束不能引用虚拟生成的列。<br>生成的列有几个用例，例如：</p>
<ul>
<li>虚拟生成列可用作简化和统一查询的方法。一个复杂的条件可以定义为生成的列，并从表上的多个查询引用，以确保它们都使用完全相同的条件</li>
<li>存储生成列可用作物化缓存，用于复杂条件，这些条件在运行中计算成本很高。</li>
<li>生成的列可以模拟功能索引：使用生成的列定义功能表达式并对其进行索引。这对处理无法直接索引的类型列非常有用</li>
<li>对于存储的生成列，这种方法的缺点是值存储两次；一次作为生成列的值，一次作为索引</li>
</ul>
]]></content>
      <categories>
        <category>mySQL</category>
      </categories>
  </entry>
  <entry>
    <title>高性能MYSQL-读书笔记之索引(一)</title>
    <url>/2021/03/13/%E9%AB%98%E6%80%A7%E8%83%BDMYSQL-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%B4%A2%E5%BC%95-%E4%B8%80/</url>
    <content><![CDATA[<h3 id="索引基础"><a href="#索引基础" class="headerlink" title="索引基础"></a>索引基础</h3><h4 id="索引的类型"><a href="#索引的类型" class="headerlink" title="索引的类型"></a>索引的类型</h4><h5 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B-Tree索引"></a>B-Tree索引</h5><p>目前大部分数据库系统及文件系统都采用B-Tree或其变种B+Tree作为索引结构.<br>存储引擎以不同的方式使用B-Tree索引：</p>
<ul>
<li>MyISAM使用前缀压缩技术使得索引更小；MyISAM索引通过数据的无力位置引用被索引的行</li>
<li>InnoDB则按照原数据格式进行存储；InnoDB根据主键引用被索引的行</li>
</ul>
<p>可使用B-Tree索引的查询类型。B-Tree索引适用于全键值、键值范围或键前缀查找：</p>
<span id="more"></span>
<ul>
<li>全值匹配：和索引种的所有列进行匹配</li>
<li>匹配最左前缀：使用索引的第一列</li>
<li>匹配列前缀：匹配某一列的值的开头部分</li>
<li>匹配范围值：</li>
<li>精确匹配某一列并范围匹配另外一列</li>
<li>只访问索引的查询</li>
</ul>
<p>因为索引树中的结点是有序的，所以索引除了查找之外，还可以用于查询种的 ORDER BY 操作。只要 ORDER BY 子句满足以上的查询类型，则这个索引也可以满足排序需求</p>
<p>关于B-Tree索引的限制：</p>
<ul>
<li>如果不是按照索引的最左列开始查找，则无法使用索引</li>
<li>不能跳过索引中的列</li>
<li>如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找</li>
</ul>
<h4 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h4><p>哈希索引(hash index)基于哈希表实现，只有精确匹配索引所有列的查询才有效。<br>哈希索引的缺点：</p>
<ul>
<li>哈希索引只包含哈希值和行指针，不存储字段值，导致不能使用索引中的值来避免读取行</li>
<li>哈希索引数据并不是按照索引值顺序存储的，无法用于排序</li>
<li>哈希表不支持部分索引列匹配查找，因为哈希索引始终使用索引列的全部内容来计算哈希值的。例如，在数据列（A，B）上建立哈希索引，如果只查询A列，则无法使用索引</li>
<li>哈希只支持等值比较查询，包括=、IN()、&gt;、&lt;,不支持任何范围查询</li>
<li>如果哈希冲突很多，索引维护的代价会很高</li>
</ul>
<h4 id="空间数据索引"><a href="#空间数据索引" class="headerlink" title="空间数据索引"></a>空间数据索引</h4><h5 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h5><p>索引的优点<br>总结三个优点：</p>
<ul>
<li>1、索引大大减少了服务器需要扫描的数据量</li>
<li>2、索引可以帮助服务器避免排序和临时表</li>
<li>3、索引可以将随机I/O变为顺序I/O</li>
</ul>
]]></content>
      <categories>
        <category>mySQL</category>
      </categories>
  </entry>
  <entry>
    <title>高性能MYSQL-读书笔记之索引(二)</title>
    <url>/2021/03/14/%E9%AB%98%E6%80%A7%E8%83%BDMYSQL-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%B4%A2%E5%BC%95-%E4%BA%8C/</url>
    <content><![CDATA[<h3 id="高性能索引策略"><a href="#高性能索引策略" class="headerlink" title="高性能索引策略"></a>高性能索引策略</h3><p>正确的创建和使用索引是实现高性能查询的基础。</p>
<h4 id="独立的列"><a href="#独立的列" class="headerlink" title="独立的列"></a>独立的列</h4><p>“独立的列”是指索引列不能是表达式的一部分，也不能是函数的参数。举个例子：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">## 下面这个查询无法使用actor_id列的索引</span><br><span class="line"><span class="keyword">SELECT</span> actor_id <span class="keyword">FROM</span> sakila.actor <span class="keyword">WHERE</span> actor_id <span class="operator">+</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<h4 id="前缀索引和索引选择性"><a href="#前缀索引和索引选择性" class="headerlink" title="前缀索引和索引选择性"></a>前缀索引和索引选择性</h4><p>当需要索引很长的字符列时，会让索引变得大且慢。<span id="more"></span>通常可以索引开始的部分字符，可以减少索引空间，提高索引效率。但这样操作会降低索引的选择性。索引的选择性是指，不重复的索引值和数据表的记录总数(#T)的比值，范围在 1/#T到1之间。索引的选择性越高则查询效率越高。对于 BLOB、TEXT或很长的VARCHAR类型的列，必须使用前缀索引，因为MYSQL不允许这些列的完整长度。在使用前缀索引时，要选择足够长的前缀以保证较高的选择性，同时又不能太长。如何确定呢？举个例子:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">LEFT</span>(city, <span class="number">3</span>)) <span class="operator">/</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> sel3 <span class="keyword">FROM</span> sakila.city_demo;       ## <span class="number">0.0239</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">LEFT</span>(city, <span class="number">4</span>)) <span class="operator">/</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> sel4 <span class="keyword">FROM</span> sakila.city_demo;       ## <span class="number">0.0293</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">LEFT</span>(city, <span class="number">5</span>)) <span class="operator">/</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> sel5 <span class="keyword">FROM</span> sakila.city_demo;       ## <span class="number">0.0305</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">LEFT</span>(city, <span class="number">6</span>)) <span class="operator">/</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> sel6 <span class="keyword">FROM</span> sakila.city_demo;       ## <span class="number">0.0309</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">LEFT</span>(city, <span class="number">7</span>)) <span class="operator">/</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> sel7 <span class="keyword">FROM</span> sakila.city_demo;       ## <span class="number">0.0310</span> 查询显示长度为<span class="number">7</span>时，最接近</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> city) <span class="operator">/</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> selAll <span class="keyword">FROM</span> sakila.city_demo;   ## <span class="number">0.0312</span></span><br><span class="line">## 只看平均选择性是不够的，需要考虑最坏情况下的选择性</span><br></pre></td></tr></table></figure>
<p>当找到合适的前缀长度，就要创建前缀索引列，如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> sakila.city_demo <span class="keyword">ADD</span> KEY(city(<span class="number">7</span>));</span><br></pre></td></tr></table></figure>
<p>前缀索引需要注意的是MYSQL无法使用前缀索引做 ORDER BY 和 GROUP BY，也无法使用前缀索引做覆盖扫描。</p>
<h4 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h4><p>在多个列上建立独立的单列索引大部分情况下并不能提高MYSQL的查询性能。索引合并策略有时候是一种优化的结果，但实际上更多时候说明了表上的索引建的很糟糕。</p>
<h4 id="选择合适的索引列顺序"><a href="#选择合适的索引列顺序" class="headerlink" title="选择合适的索引列顺序"></a>选择合适的索引列顺序</h4><h4 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h4><p>聚簇索引并不是单独的索引类型，而是一种数据存储方式。当表有聚簇索引时，它的数据行实际存放在索引的叶子页(leaf page)中。一个表只能有一个聚簇索引。优点：</p>
<ul>
<li>可以把相关数据保存在一起</li>
<li>数据访问更快</li>
<li>使用覆盖索引扫描的查询可以直接使用页节点中的主键值。</li>
</ul>
<p>缺点：</p>
<ul>
<li>插入速度严重依赖插入顺序。如果不是按照主键顺序加载数据，那么加载完成后最好使用OPTIMIZE TABLE命令重新组织一下表</li>
<li>更新聚簇索引列的代价很高，因为会强制InnoDB将每个被更新的行移动到新的位置</li>
<li>基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临“页分裂(page split)”的问题。</li>
<li>聚簇索引可能导致全表扫描变慢</li>
<li>二级索引(非聚簇索引)可能比想象的更大，因为在二级索引的叶子结点包含了引用行的主键列</li>
<li>二级索引访问需要两次索引查找</li>
</ul>
<h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>如果一个索引包含或者说覆盖所有需要查询的字段的值，就是“覆盖索引”。覆盖索引的优点：</p>
<ul>
<li>索引条目通常远小于数据行大小</li>
<li>如果二级主键能够覆盖查询，则可以避免对主键索引的二次查询。覆盖索引必须要存储索引列的值，而哈希索引、空间索引、全文索引等都不存储，所以只能使用B-Tree索引做覆盖索引。</li>
</ul>
<h4 id="使用索引扫描来做排序"><a href="#使用索引扫描来做排序" class="headerlink" title="使用索引扫描来做排序"></a>使用索引扫描来做排序</h4><p>MySQL有两种方式可以生成有序的结果：</p>
<ul>
<li>通过排序操作</li>
<li>按索引顺序扫描。如果EXPLAIN出来的type列的值为“index”，则说明使用了索引扫描做排序</li>
</ul>
<p>满足索引做排序的条件如下：</p>
<ul>
<li>只有当索引的列顺序和ORDER BY子句的顺序完全一致，且所有的列的排序方向都一样时，MySQL才能使用索引对结果排序。</li>
<li>如果需要联表查询，则只有当ORDER BY子句引用的字段全部为第一个表时，才能使用索引做排序。</li>
<li>ORDER BY子句和查询的限制一样：需要满足索引的最左前缀要求<br>示例：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">## rental表中有以下索引：</span><br><span class="line">## <span class="keyword">UNIQUE</span> KEY rental_date(rental_date, inventory_id, customer_id)</span><br><span class="line">## key idx_fk_inventory_id(inventory_id)</span><br><span class="line">## key_idx_fk_customer_id(customer_id)</span><br><span class="line">## key_idx_fk_staff_id(staff_id)</span><br><span class="line">## 这个查询可以利用索引排序，因为索引的第一列提供了常量条件,而使用第二列排序，将两列组合，就符合索引的最左前缀</span><br><span class="line"><span class="keyword">SELECT</span> rental_id, staff_id <span class="keyword">FROM</span> sakila.rental <span class="keyword">WHERE</span> rental_date <span class="operator">=</span> <span class="string">&#x27;2019-03-31&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> inventory_id <span class="keyword">DESC</span>;</span><br><span class="line"></span><br><span class="line">## 这个也可以索引排序,因为<span class="keyword">ORDER</span> <span class="keyword">BY</span> 使用的两列就是索引的最左前缀</span><br><span class="line"><span class="keyword">SELECT</span> rental_id, staff_id <span class="keyword">FROM</span> sakila.rental <span class="keyword">WHERE</span> rental_date <span class="operator">&lt;</span> <span class="string">&#x27;2019-03-31&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> rental_date, inventory_id;</span><br><span class="line"></span><br><span class="line">## 下面是一些不能使用索引做排序的查询</span><br><span class="line">## 这个查询使用了两种不同的排序方向，但索引列都是正序排序的</span><br><span class="line"><span class="keyword">SELECT</span> rental_id, staff_id <span class="keyword">FROM</span> sakila.rental <span class="keyword">WHERE</span> rental_date <span class="operator">=</span> <span class="string">&#x27;2019-03-31&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> inventory_id <span class="keyword">DESC</span>, customer_id <span class="keyword">ASC</span>;</span><br><span class="line">## 这个查询的<span class="keyword">ORDER</span> <span class="keyword">BY</span> 子句中引用了一个不在索引中的列</span><br><span class="line"><span class="keyword">SELECT</span> rental_id, staff_id <span class="keyword">FROM</span> sakila.rental <span class="keyword">WHERE</span> rental_date <span class="operator">=</span> <span class="string">&#x27;2019-03-31&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> inventory_id, staff_id;</span><br><span class="line">## 这个查询的<span class="keyword">WHERE</span>和<span class="keyword">ORDER</span> <span class="keyword">BY</span>中的列无法组合成索引的最左前缀</span><br><span class="line"><span class="keyword">SELECT</span> rental_id, staff_id <span class="keyword">FROM</span> sakila.rental <span class="keyword">WHERE</span> rental_date <span class="operator">=</span> <span class="string">&#x27;2019-03-31&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> customer_id;</span><br><span class="line">##  这个查询在索引列的第一列上是范围条件，所以无法使用索引的其余列</span><br><span class="line"><span class="keyword">SELECT</span> rental_id, staff_id <span class="keyword">FROM</span> sakila.rental <span class="keyword">WHERE</span> rental_date <span class="operator">&gt;</span> <span class="string">&#x27;2019-03-31&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> inventory_id, customer_id;</span><br><span class="line">## 这个查询在inventory_id列上有多个等于条件。对于排序来说，这也是一种范围查询</span><br><span class="line"><span class="keyword">SELECT</span> rental_id, staff_id <span class="keyword">FROM</span> sakila.rental <span class="keyword">WHERE</span> rental_date <span class="operator">=</span> <span class="string">&#x27;2019-03-31&#x27;</span> <span class="keyword">AND</span> inventory_id <span class="keyword">IN</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="keyword">ORDER</span> <span class="keyword">BY</span> customer_id;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="冗余和重复的索引"><a href="#冗余和重复的索引" class="headerlink" title="冗余和重复的索引"></a>冗余和重复的索引</h4><p>重复索引是指在相同的列上按照相同的顺序创建相同类型的索引。应该避免重复索引。冗余索引和重复索引有一些不同。例如：</p>
<ul>
<li>创建了索引(A, B)，在创建索引(A)就是冗余索引，因为这只是前一个索引的前缀索引</li>
<li>创建了索引(A, B)，在创建索引(B, A)，则不是冗余索引，索引(B)也不是</li>
</ul>
]]></content>
      <categories>
        <category>mySQL</category>
      </categories>
  </entry>
  <entry>
    <title>GO语言基础-day01</title>
    <url>/2021/03/22/GO%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80-day01/</url>
    <content><![CDATA[<h3 id="1、GO的执行原理"><a href="#1、GO的执行原理" class="headerlink" title="1、GO的执行原理"></a>1、GO的执行原理</h3><p><img src="http://free-cn-01.oss.tusy.xyz/asf/jfs/t1/157815/21/15246/134300/6058acb5E3838c238/2a16ca8950783f07.png" alt="GO的源码文件分类"><br>如上图分为三类：</p>
<span id="more"></span>
<ul>
<li>1、命令源码文件<ul>
<li>1、声明自己属于 main 代码包、包含无参数声明和结果声明的 main 函数。</li>
<li>2、命令源码文件被安装以后，GOPATH 如果只有一个工作区，那么相应的可执行文件会被存放当前工作区的 bin 文件夹下；如果有多个工作区，就会安装到 GOBIN 指向的目录下。</li>
<li>3、命令源码文件是 Go 程序的入口。</li>
<li>4、同一个代码包中最好也不要放多个命令源码文件。多个命令源码文件虽然可以分开单独 go run 运行起来，但是无法通过 go build 和 go install。</li>
</ul>
</li>
<li>2、库源码文件<ul>
<li>1、库源码文件就是不具备命令源码文件上述两个特征的源码文件。存在于某个代码包中的普通的源码文件。</li>
<li>2、库源码文件被安装后，相应的归档文件（.a 文件）会被存放到当前工作区的 pkg 的平台相关目录下。</li>
</ul>
</li>
<li>3、测试源码文件<ul>
<li>1、名称以 _test.go 为后缀的代码文件，并且必须包含 Test 或者 Benchmark 名称前缀的函数：</li>
<li>2、<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 名称以 Test 为名称前缀的函数，只能接受 *testing.T 的参数，这种测试函数是功能测试函数。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestXXX</span><span class="params">( t *testing.T)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 名称以 Benchmark 为名称前缀的函数，只能接受 *testing.B 的参数，这种测试函数是性能测试函数。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkXXX</span><span class="params">( b *testing.B)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="2、GO的命令"><a href="#2、GO的命令" class="headerlink" title="2、GO的命令"></a>2、GO的命令</h3><p>截至V1.12里面基本命令有以下17个。<br>我们可以打开终端输入：go help即可看到Go的这些命令以及简介。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">bug         start a bug report</span><br><span class="line">build       compile packages and dependencies</span><br><span class="line">clean       remove object files and cached files</span><br><span class="line">doc         show documentation for package or symbol</span><br><span class="line">env         print Go environment information</span><br><span class="line">fix         update packages to use new APIs</span><br><span class="line">fmt         gofmt (reformat) package sources</span><br><span class="line">generate    generate Go files by processing source</span><br><span class="line">get         download and install packages and dependencies</span><br><span class="line">install     compile and install packages and dependencies</span><br><span class="line">list        list packages or modules</span><br><span class="line">mod         module maintenance</span><br><span class="line">run         compile and run Go program</span><br><span class="line">test        test packages</span><br><span class="line">tool        run specified go tool</span><br><span class="line">version     print Go version</span><br><span class="line">vet         report likely mistakes in packages</span><br></pre></td></tr></table></figure>
<p>其中和编译相关的有build、get、install、run这4个。接下来就依次看看这四个的作用。<br>在详细分析这4个命令之前，先罗列一下通用的命令标记，以下这些命令都可适用的：<br>|   名称   |   说明   |<br>| —- | —- |<br>|  -a  |   用于强制重新编译所有涉及的 Go 语言代码包（包括 Go 语言标准库中的代码包），即使它们已经是最新的了。该标记可以让我们有机会通过改动底层的代码包做一些实验。   |<br>|  -n  |  使命令仅打印其执行过程中用到的所有命令，而不去真正执行它们。如果不只想查看或者验证命令的执行过程，而不想改变任何东西，使用它正好合适。    |<br>| -race  |  用于检测并报告指定 Go 语言程序中存在的数据竞争问题。当用 Go 语言编写并发程序的时候，这是很重要的检测手段之一。    |<br>| -v   |   用于打印命令执行过程中涉及的代码包。这一定包括我们指定的目标代码包，并且有时还会包括该代码包直接或间接依赖的那些代码包。这会让你知道哪些代码包被执行过了。   |<br>| -work   |   用于打印命令执行时生成和使用的临时工作目录的名字，且命令执行完成后不删除它。这个目录下的文件可能会对你有用，也可以从侧面了解命令的执行过程。如果不添加此标记，那么临时工作目录会在命令执行完毕前删除。   |<br>|  -x    |   使命令打印其执行过程中用到的所有命令，并同时执行它们。   |</p>
<h5 id="2-1、go-run"><a href="#2-1、go-run" class="headerlink" title="2.1、go run"></a>2.1、go run</h5><p>专门用来运行命令源码文件的命令，注意，这个命令不是用来运行所有 Go 的源码文件的！<br>go run 命令只能接受一个命令源码文件以及若干个库源码文件（必须同属于 main 包）作为文件参数，且不能接受测试源码文件。它在执行时会检查源码文件的类型。如果参数中有多个或者没有命令源码文件，那么 go run 命令就只会打印错误提示信息并退出，而不会继续执行。<br><img src="http://free-cn-01.cdn.bilnn.com/ddfilesass/jfs/t1/156225/37/17963/50322/605bd9f9E4a81f0e3/e25206db86f5ac21.jpg" alt="go run执行过程"><br>go run 命令在第二次执行的时候，如果发现导入的代码包没有发生变化，那么 go run 不会再次编译这个导入的代码包。直接静态链接进来。</p>
<h5 id="2-2、go-build"><a href="#2-2、go-build" class="headerlink" title="2.2、go build"></a>2.2、go build</h5><p>go build 命令主要是用于测试编译。在包的编译过程中，若有必要，会同时编译与之相关联的包。</p>
<ul>
<li>1、如果是普通包，当你执行go build命令后，不会产生任何文件。</li>
<li>2、如果是main包，当只执行go build命令后，会在当前目录下生成一个可执行文件。如果需要在$GOPATH/bin目录下生成相应的exe文件，需要执行go install 或者使用 go build -o 路径/可执行文件。</li>
<li>3、如果某个文件夹下有多个文件，而你只想编译其中某一个文件，可以在 go build 之后加上文件名，例如 go build a.go；go build 命令默认会编译当前目录下的所有go文件。</li>
<li>4、你也可以指定编译输出的文件名。比如，我们可以指定go build -o 可执行文件名，默认情况是你的package名(非main包)，或者是第一个源文件的文件名(main包)。</li>
<li>5、go build 会忽略目录下以”_”或者”.”开头的go文件。</li>
<li>6、如果你的源代码针对不同的操作系统需要不同的处理，那么你可以根据不同的操作系统后缀来命名文件。</li>
</ul>
<p>当代码包中有且仅有一个命令源码文件的时候，在文件夹所在目录中执行 go build 命令，会在该目录下生成一个与目录同名的可执行文件。</p>
<p><img src="http://free-cn-01.cdn.bilnn.com/ddfilesass/jfs/t1/174535/2/269/132299/605bdb5bE4356d523/c1365aefd78680ba.png" alt="执行区别"></p>
<h5 id="2-3、go-install"><a href="#2-3、go-install" class="headerlink" title="2.3、go install"></a>2.3、go install</h5><h5 id="2-4、go-get"><a href="#2-4、go-get" class="headerlink" title="2.4、go get"></a>2.4、go get</h5>]]></content>
      <categories>
        <category>GO基础</category>
      </categories>
      <tags>
        <tag>GO</tag>
      </tags>
  </entry>
  <entry>
    <title>GO基础语法-day02</title>
    <url>/2021/03/25/GO%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95-day02/</url>
    <content><![CDATA[<h3 id="1、变量的使用"><a href="#1、变量的使用" class="headerlink" title="1、变量的使用"></a>1、变量的使用</h3><h4 id="1-1、声明变量"><a href="#1-1、声明变量" class="headerlink" title="1.1、声明变量"></a>1.1、声明变量</h4><p>以字母或下划线开头，由一个或多个字母、数字、下划线组成</p>
<h5 id="1-1-1、声明一个变量"><a href="#1-1-1、声明一个变量" class="headerlink" title="1.1.1、声明一个变量"></a>1.1.1、声明一个变量</h5><p>第一种，指定变量类型，声明后若不赋值，使用默认值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="keyword">type</span></span><br><span class="line">name = <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>第二种，根据值自行判定变量类型(类型推断Type inference)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>第三种，省略var, 注意 :=左侧的变量不应该是已经声明过的(多个变量同时声明时，至少保证一个是新变量)，否则会导致编译错误(简短声明)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">name := <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例如</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">10</span></span><br><span class="line">c : = <span class="number">10</span></span><br></pre></td></tr></table></figure>

<h5 id="1-1-2、多变量声明"><a href="#1-1-2、多变量声明" class="headerlink" title="1.1.2、多变量声明"></a>1.1.2、多变量声明</h5><p>第一种，以逗号分隔，声明与赋值分开，若不赋值，存在默认值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name1, name2, name3 <span class="keyword">type</span></span><br><span class="line">name1, name2, name3 = v1, v2, v3</span><br></pre></td></tr></table></figure>

<p>第二种，直接赋值，下面的变量类型可以是不同的类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name1, name2, name3 = v1, v2, v3</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第三种，集合类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    name1 type1</span><br><span class="line">    name2 type2</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="1-2、注意事项"><a href="#1-2、注意事项" class="headerlink" title="1.2、注意事项"></a>1.2、注意事项</h4><ul>
<li>1、变量必须先定义才能使用</li>
<li>2、go语言是静态语言，要求变量的类型和赋值的类型必须一致。</li>
<li>3、变量名不能冲突。(同一个作用于域内不能冲突)</li>
<li>4、简短定义方式，左边的变量名至少有一个是新的</li>
<li>5、简短定义方式，不能定义全局变量。</li>
<li>6、变量的零值。也叫默认值。</li>
<li>7、变量定义了就要使用，否则无法通过编译。</li>
</ul>
<h3 id="2、常量的使用"><a href="#2、常量的使用" class="headerlink" title="2、常量的使用"></a>2、常量的使用</h3><p>常量是一个简单值的标识符，在程序运行时，不会被修改的量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> identifier [<span class="keyword">type</span>] = value</span><br><span class="line">显式类型定义： <span class="keyword">const</span> b <span class="keyword">string</span> = <span class="string">&quot;abc&quot;</span></span><br><span class="line">隐式类型定义： <span class="keyword">const</span> b = <span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">const</span> LENGTH <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">   <span class="keyword">const</span> WIDTH <span class="keyword">int</span> = <span class="number">5</span>   </span><br><span class="line">   <span class="keyword">var</span> area <span class="keyword">int</span></span><br><span class="line">   <span class="keyword">const</span> a, b, c = <span class="number">1</span>, <span class="literal">false</span>, <span class="string">&quot;str&quot;</span> <span class="comment">//多重赋值</span></span><br><span class="line"></span><br><span class="line">   area = LENGTH * WIDTH</span><br><span class="line">   fmt.Printf(<span class="string">&quot;面积为 : %d&quot;</span>, area)</span><br><span class="line">   <span class="built_in">println</span>()</span><br><span class="line">   <span class="built_in">println</span>(a, b, c)   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>常量可以作为枚举，常量组</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Unknown = <span class="number">0</span></span><br><span class="line">    Female = <span class="number">1</span></span><br><span class="line">    Male = <span class="number">2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>常量组中如不指定类型和初始化值，则与上一行非空常量右值相同</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> (</span><br><span class="line">        x <span class="keyword">uint16</span> = <span class="number">16</span></span><br><span class="line">        y</span><br><span class="line">        s = <span class="string">&quot;abc&quot;</span></span><br><span class="line">        z</span><br><span class="line">    )</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%T,%v\n&quot;</span>, y, y)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%T,%v\n&quot;</span>, z, z)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint16</span>,<span class="number">16</span></span><br><span class="line"><span class="keyword">string</span>,abc</span><br></pre></td></tr></table></figure>
<h4 id="2-1、常量注意事项"><a href="#2-1、常量注意事项" class="headerlink" title="2.1、常量注意事项"></a>2.1、常量注意事项</h4><ul>
<li>1、常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型</li>
<li>2、不曾使用的常量，在编译的时候，是不会报错的</li>
<li>3、显示指定类型的时候，必须确保常量左右值类型一致，需要时可做显示类型转换。这与变量就不一样了，变量是可以是不同的类型值</li>
</ul>
<h4 id="2-2、iota"><a href="#2-2、iota" class="headerlink" title="2.2、iota"></a>2.2、iota</h4><p>iota，特殊常量，可以认为是一个可以被编译器修改的常量<br>iota 可以被用作枚举值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a = <span class="literal">iota</span></span><br><span class="line">    b = <span class="literal">iota</span></span><br><span class="line">    c = <span class="literal">iota</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个 iota 等于 0，每当 iota 在新的一行被使用时，它的值都会自动加 1；所以 a=0, b=1, c=2 可以简写为如下形式：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a = <span class="literal">iota</span></span><br><span class="line">    b</span><br><span class="line">    c</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>iota用法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> (</span><br><span class="line">            a = <span class="literal">iota</span>   <span class="comment">//0</span></span><br><span class="line">            b          <span class="comment">//1</span></span><br><span class="line">            c          <span class="comment">//2</span></span><br><span class="line">            d = <span class="string">&quot;ha&quot;</span>   <span class="comment">//独立值，iota += 1</span></span><br><span class="line">            e          <span class="comment">//&quot;ha&quot;   iota += 1</span></span><br><span class="line">            f = <span class="number">100</span>    <span class="comment">//iota +=1</span></span><br><span class="line">            g          <span class="comment">//100  iota +=1</span></span><br><span class="line">            h = <span class="literal">iota</span>   <span class="comment">//7,恢复计数</span></span><br><span class="line">            i          <span class="comment">//8</span></span><br><span class="line">    )</span><br><span class="line">    fmt.Println(a,b,c,d,e,f,g,h,i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果 0 1 2 ha ha 100 100 7 8</span></span><br></pre></td></tr></table></figure>
<p>如果中断iota自增，则必须显式恢复。且后续自增值按行序递增，自增默认是int类型，可以自行进行显示指定类型。数字常量不会分配存储空间，无须像变量那样通过内存寻址来取值，因此无法获取地址</p>
]]></content>
      <categories>
        <category>GO基础</category>
      </categories>
      <tags>
        <tag>GO</tag>
      </tags>
  </entry>
  <entry>
    <title>GO运算符-day03</title>
    <url>/2021/03/28/GO%E8%BF%90%E7%AE%97%E7%AC%A6-day03/</url>
    <content><![CDATA[<h3 id="1、运算符"><a href="#1、运算符" class="headerlink" title="1、运算符"></a>1、运算符</h3><h4 id="1-1、算术运算符"><a href="#1-1、算术运算符" class="headerlink" title="1.1、算术运算符"></a>1.1、算术运算符</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">+ - * / %(求余) ++ --</span><br></pre></td></tr></table></figure>

<h4 id="1-2、关系运算符"><a href="#1-2、关系运算符" class="headerlink" title="1.2、关系运算符"></a>1.2、关系运算符</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">== != &gt; &lt; &gt;= &lt;=</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1-3、逻辑运算符"><a href="#1-3、逻辑运算符" class="headerlink" title="1.3、逻辑运算符"></a>1.3、逻辑运算符</h4><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;&amp;</td>
<td>逻辑与运算符。如果两个操作数都非零，则条件变为真</td>
</tr>
<tr>
<td>||</td>
<td>逻辑或操作。如果任何两个操作数是非零，则条件变为真</td>
</tr>
<tr>
<td>!</td>
<td>逻辑非运算符。使用反转操作数的逻辑状态。如果条件为真，那么逻辑非操后结果为假</td>
</tr>
</tbody></table>
<span id="more"></span>
<h4 id="1-4、位运算符"><a href="#1-4、位运算符" class="headerlink" title="1.4、位运算符"></a>1.4、位运算符</h4><table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>A&amp;B</th>
<th>A|B</th>
<th>A^B</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
</tbody></table>
<p>举个例子，假设A = 60， B = 13<br>|   运算符   |   描述   |  示例    |<br>| —- | —- | —- |<br>|  &amp;    |  二进制与操作    | (A &amp; B) = 12, 也就是 0000 1100     |<br>|  |    |  二进制或操作    | (A | B) = 61, 也就是 0011 1101     |<br>|  ^    |  二进制异或操作，如果它被设置在一个操作数就是按位取非    |  (A ^ B) = 49, 也就是 0011 0001    |<br>|  &amp;^    | 二进制位清空     |   (A&amp;^B)=48，也就是110000   |<br>|  &lt;&lt;    |  二进制左移位    |   A &lt;&lt; 2 =240 也就是 1111 0000   |<br>|  &gt;&gt;    |  二进制右移位    |   A &gt;&gt; 2 = 15 也就是 0000 1111   |</p>
<h4 id="1-4、赋值运算符"><a href="#1-4、赋值运算符" class="headerlink" title="1.4、赋值运算符"></a>1.4、赋值运算符</h4><table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>=</td>
<td>简单的赋值操作符，分配值从右边的操作数左侧的操作数</td>
<td>C = A + B 将分配A + B的值到C</td>
</tr>
<tr>
<td>+=</td>
<td>相加并赋值运算符，它增加了右操作数左操作数和分配结果左操作数</td>
<td>C += A 相当于 C = C + A</td>
</tr>
<tr>
<td>-=</td>
<td>减和赋值运算符，它减去右操作数从左侧的操作数和分配结果左操作数</td>
<td>C -= A 相当于 C = C - A</td>
</tr>
<tr>
<td>*=</td>
<td>乘法和赋值运算符，它乘以右边的操作数与左操作数和分配结果左操作数</td>
<td>C *= A 相当于 C = C * A</td>
</tr>
<tr>
<td>/=</td>
<td>除法赋值运算符，它把左操作数与右操作数和分配结果左操作数</td>
<td>C /= A 相当于 C = C / A</td>
</tr>
<tr>
<td>%=</td>
<td>模量和赋值运算符，它需要使用两个操作数的模量和分配结果左操作数</td>
<td>C %= A 相当于 C = C % A</td>
</tr>
<tr>
<td>&lt;&lt;=</td>
<td>左移位并赋值运算符</td>
<td>C &lt;&lt;= 2 相同于 C = C &lt;&lt; 2</td>
</tr>
<tr>
<td>&gt;&gt;=</td>
<td>向右移位并赋值运算符</td>
<td>C &gt;&gt;= 2 相同于 C = C &gt;&gt; 2</td>
</tr>
<tr>
<td>&amp;=</td>
<td>按位与赋值运算符</td>
<td>C &amp;= 2 相同于 C = C &amp; 2</td>
</tr>
<tr>
<td>^=</td>
<td>按位异或并赋值运算符</td>
<td>C ^= 2 相同于 C = C ^ 2</td>
</tr>
<tr>
<td>|=</td>
<td>按位或并赋值运算符</td>
<td>C |= 2 相同于 C = C | 2</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>GO基础</category>
      </categories>
      <tags>
        <tag>GO</tag>
      </tags>
  </entry>
  <entry>
    <title>GO数组-day04</title>
    <url>/2021/03/29/GO%E6%95%B0%E7%BB%84-day04/</url>
    <content><![CDATA[<h3 id="1、数组"><a href="#1、数组" class="headerlink" title="1、数组"></a>1、数组</h3><h4 id="1-1、声明和初始化数组"><a href="#1-1、声明和初始化数组" class="headerlink" title="1.1、声明和初始化数组"></a>1.1、声明和初始化数组</h4><p>需要指明数组的大小和存储的数据类型。<span id="more"></span></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> variable_name [SIZE] variable_type</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> balance [<span class="number">10</span>] <span class="keyword">float32</span></span><br><span class="line"><span class="keyword">var</span> balance = [<span class="number">5</span>]<span class="keyword">float32</span>&#123;<span class="number">1000.0</span>, <span class="number">2.0</span>, <span class="number">3.4</span>, <span class="number">7.0</span>, <span class="number">50.0</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化数组中 &#123;&#125; 中的元素个数不能大于 [] 中的数字。 如果忽略 [] 中的数字不设置数组大小，Go 语言会根据元素的个数来设置数组的大小：</span></span><br><span class="line"><span class="keyword">var</span> balance = []<span class="keyword">float32</span>&#123;<span class="number">1000.0</span>, <span class="number">2.0</span>, <span class="number">3.4</span>, <span class="number">7.0</span>, <span class="number">50.0</span>&#125;</span><br><span class="line">balance[<span class="number">4</span>] = <span class="number">50.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组的其他创建方式</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> a [<span class="number">4</span>] <span class="keyword">float32</span> <span class="comment">// 等价于：var arr2 = [4]float32&#123;&#125;</span></span><br><span class="line">  fmt.Println(a) <span class="comment">// [0 0 0 0]</span></span><br><span class="line">  <span class="keyword">var</span> b = [<span class="number">5</span>] <span class="keyword">string</span>&#123;<span class="string">&quot;ruby&quot;</span>, <span class="string">&quot;王二狗&quot;</span>, <span class="string">&quot;rose&quot;</span>&#125;</span><br><span class="line">  fmt.Println(b) <span class="comment">// [ruby 王二狗 rose  ]</span></span><br><span class="line">  <span class="keyword">var</span> c = [<span class="number">5</span>] <span class="keyword">int</span>&#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>&#125; <span class="comment">// byte</span></span><br><span class="line">  fmt.Println(c) <span class="comment">// [65 66 67 68 69]</span></span><br><span class="line">  d := [...] <span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;<span class="comment">// 根据元素的个数，设置数组的大小</span></span><br><span class="line">  fmt.Println(d)<span class="comment">//[1 2 3 4 5]</span></span><br><span class="line">  e := [<span class="number">5</span>] <span class="keyword">int</span>&#123;<span class="number">4</span>: <span class="number">100</span>&#125; <span class="comment">// [0 0 0 0 100]</span></span><br><span class="line">  fmt.Println(e)</span><br><span class="line">  f := [...] <span class="keyword">int</span>&#123;<span class="number">0</span>: <span class="number">1</span>, <span class="number">4</span>: <span class="number">1</span>, <span class="number">9</span>: <span class="number">1</span>&#125; <span class="comment">// [1 0 0 0 1 0 0 0 0 1]</span></span><br><span class="line">  fmt.Println(f)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1-2、遍历数组"><a href="#1-2、遍历数组" class="headerlink" title="1.2、遍历数组"></a>1.2、遍历数组</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a := [...]<span class="keyword">float64</span>&#123;<span class="number">67.7</span>, <span class="number">89.8</span>, <span class="number">21</span>, <span class="number">78</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(a); i++ &#123; <span class="comment">//looping from 0 to the length of the array</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;%d th element of a is %.2f\n&quot;</span>, i, a[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// for...range遍历数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a := [...]<span class="keyword">float64</span>&#123;<span class="number">67.7</span>, <span class="number">89.8</span>, <span class="number">21</span>, <span class="number">78</span>&#125;</span><br><span class="line">    sum := <span class="keyword">float64</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> a &#123;<span class="comment">//range returns both the index and value</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;%d the element of a is %.2f\n&quot;</span>, i, v)</span><br><span class="line">        sum += v</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;\nsum of all elements of a&quot;</span>,sum)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果您只需要值并希望忽略索引，那么可以通过使用_ blank标识符替换索引来实现这一点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> a &#123; <span class="comment">//ignores index  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1-3、多维数组"><a href="#1-3、多维数组" class="headerlink" title="1.3、多维数组"></a>1.3、多维数组</h4><p>Go 语言支持多维数组，以下为常用的多维数组声明语法方式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> variable_name [SIZE1][SIZE2]...[SIZEN] variable_type</span><br><span class="line"><span class="keyword">var</span> threedim [<span class="number">5</span>][<span class="number">10</span>][<span class="number">4</span>]<span class="keyword">int</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1-4、数组是值类型"><a href="#1-4、数组是值类型" class="headerlink" title="1.4、数组是值类型"></a>1.4、数组是值类型</h4><p>Go中的数组是值类型，而不是引用类型。这意味着当它们被分配给一个新变量时，将把原始数组的副本分配给新变量。如果对新变量进行了更改，则不会在原始数组中反映</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a := [...]<span class="keyword">string</span>&#123;<span class="string">&quot;USA&quot;</span>, <span class="string">&quot;China&quot;</span>, <span class="string">&quot;India&quot;</span>, <span class="string">&quot;Germany&quot;</span>, <span class="string">&quot;France&quot;</span>&#125;</span><br><span class="line">    b := a <span class="comment">// a copy of a is assigned to b</span></span><br><span class="line">    b[<span class="number">0</span>] = <span class="string">&quot;Singapore&quot;</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;a is &quot;</span>, a)</span><br><span class="line">    fmt.Println(<span class="string">&quot;b is &quot;</span>, b) </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a is [USA China India Germany France] </span></span><br><span class="line"><span class="comment">// b is [Singapore China India Germany France] </span></span><br></pre></td></tr></table></figure>
<p>数组的大小是类型的一部分。因此[5]int和[25]int是不同的类型。因此，数组不能被调整大小。不要担心这个限制，因为切片的存在是为了解决这个问题。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">5</span>, <span class="number">78</span>, <span class="number">8</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> b [<span class="number">5</span>]<span class="keyword">int</span></span><br><span class="line">    b = a <span class="comment">//not possible since [3]int and [5]int are distinct types</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>GO基础</category>
      </categories>
      <tags>
        <tag>GO</tag>
      </tags>
  </entry>
  <entry>
    <title>GO切片-day05</title>
    <url>/2021/03/29/GO%E5%88%87%E7%89%87-day05/</url>
    <content><![CDATA[<h3 id="1、什么是切片"><a href="#1、什么是切片" class="headerlink" title="1、什么是切片"></a>1、什么是切片</h3><p>切片是一种数据结构。是一个很小的对象，对底层数组进行了抽象，并提供相关的操作方法。<br>从概念上面来说slice像一个结构体，这个结构体包含了三个字段：</p>
<ul>
<li>1、指向底层数组的指针，指向数组中slice指定的开始位置</li>
<li>2、长度，即slice的长度，切片访问的元素的个数</li>
<li>3、最大长度，也就是slice开始位置到数组的最后位置的长度，即容量<span id="more"></span></li>
</ul>
<h3 id="2、创建和初始化"><a href="#2、创建和初始化" class="headerlink" title="2、创建和初始化"></a>2、创建和初始化</h3><h4 id="2-1、make和切片字面量"><a href="#2-1、make和切片字面量" class="headerlink" title="2.1、make和切片字面量"></a>2.1、make和切片字面量</h4><p>使用内置的make函数创建切片，示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// c创建一个字符串切片，长度和容量都是5</span></span><br><span class="line">slice := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果只指定长度，那切片的容量和长度相等。也可以分别指定长度和容量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个整型切片，长度为3，容量为5</span></span><br><span class="line">slice := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过字面量来声明切片</span></span><br><span class="line"><span class="comment">// 创建字符串切片</span></span><br><span class="line">slice := []<span class="keyword">string</span>&#123;<span class="string">&quot;red&quot;</span>, <span class="string">&quot;Blue&quot;</span>, <span class="string">&quot;Green&quot;</span>, <span class="string">&quot;Yellow&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-2、nil和空切片"><a href="#2-2、nil和空切片" class="headerlink" title="2.2、nil和空切片"></a>2.2、nil和空切片</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建nil整型切片</span></span><br><span class="line"><span class="keyword">var</span> slice []<span class="keyword">int</span></span><br></pre></td></tr></table></figure>
<p>在Go语言里，nil切片是很常见的创建切片的方法。nil切片可用于很多标准库和内置函数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明空切片</span></span><br><span class="line">slice := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">slice := []<span class="keyword">int</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、切片的使用"><a href="#3、切片的使用" class="headerlink" title="3、切片的使用"></a>3、切片的使用</h3><h4 id="3-1、append"><a href="#3-1、append" class="headerlink" title="3.1、append()"></a>3.1、append()</h4><h4 id="3-2、copy"><a href="#3-2、copy" class="headerlink" title="3.2、copy()"></a>3.2、copy()</h4><h3 id="4、多维切片"><a href="#4、多维切片" class="headerlink" title="4、多维切片"></a>4、多维切片</h3>]]></content>
      <categories>
        <category>GO基础</category>
      </categories>
      <tags>
        <tag>GO</tag>
      </tags>
  </entry>
  <entry>
    <title>GO指针-day08</title>
    <url>/2021/04/03/GO%E6%8C%87%E9%92%88-day08/</url>
    <content><![CDATA[<h3 id="1、指针的声明"><a href="#1、指针的声明" class="headerlink" title="1、指针的声明"></a>1、指针的声明</h3><p>声明指针， *T是指针变量的类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> var_name *<span class="keyword">var</span>-<span class="keyword">type</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ip *<span class="keyword">int</span>        <span class="comment">/* 指向整型*/</span></span><br><span class="line"><span class="keyword">var</span> fp *<span class="keyword">float32</span>    <span class="comment">/* 指向浮点型 */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<span id="more"></span>
]]></content>
      <categories>
        <category>GO基础</category>
      </categories>
      <tags>
        <tag>GO</tag>
      </tags>
  </entry>
  <entry>
    <title>GO函数-day07</title>
    <url>/2021/04/02/GO%E5%87%BD%E6%95%B0-day07/</url>
    <content><![CDATA[<h3 id="1、函数的声明"><a href="#1、函数的声明" class="headerlink" title="1、函数的声明"></a>1、函数的声明</h3><p>go语言至少有一个main函数<br>语法格式：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcName</span><span class="params">(parametername type1, parametername type2)</span> <span class="params">(output1 type1, output2 type2)</span></span> &#123;</span><br><span class="line"><span class="comment">//这里是处理逻辑代码</span></span><br><span class="line"><span class="comment">//返回多个值</span></span><br><span class="line"><span class="keyword">return</span> value1, value2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h3 id="2、参数传递"><a href="#2、参数传递" class="headerlink" title="2、参数传递"></a>2、参数传递</h3><p>值传递和引用传递</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 值传递</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line">   <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">/* 声明函数变量 */</span></span><br><span class="line">   getSquareRoot := <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">      <span class="keyword">return</span> math.Sqrt(x)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 使用函数 */</span></span><br><span class="line">   fmt.Println(getSquareRoot(<span class="number">9</span>))</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用传递</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="comment">//简单的一个函数，实现了参数+1的操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add1</span><span class="params">(a *<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="comment">// 请注意，</span></span><br><span class="line">*a = *a+<span class="number">1</span> <span class="comment">// 修改了a的值</span></span><br><span class="line"><span class="keyword">return</span> *a <span class="comment">// 返回新值</span></span><br><span class="line">&#125; f</span><br><span class="line">unc main() &#123;</span><br><span class="line">x := <span class="number">3</span></span><br><span class="line">fmt.Println(<span class="string">&quot;x = &quot;</span>, x) <span class="comment">// 应该输出 &quot;x = 3&quot;</span></span><br><span class="line">x1 := add1(&amp;x) <span class="comment">// 调用 add1(&amp;x) 传x的地址</span></span><br><span class="line">fmt.Println(<span class="string">&quot;x+1 = &quot;</span>, x1) <span class="comment">// 应该输出 &quot;x+1 = 4&quot;</span></span><br><span class="line">fmt.Println(<span class="string">&quot;x = &quot;</span>, x) <span class="comment">// 应该输出 &quot;x = 4&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3、函数的返回值"><a href="#3、函数的返回值" class="headerlink" title="3、函数的返回值"></a>3、函数的返回值</h3><p>一个函数可以没有返回值，也可以有一个返回值，也可以有返回多个值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   a, b := swap(<span class="string">&quot;Mahesh&quot;</span>, <span class="string">&quot;Kumar&quot;</span>)</span><br><span class="line">   fmt.Println(a, b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SumAndProduct</span><span class="params">(A, B <span class="keyword">int</span>)</span> <span class="params">(add <span class="keyword">int</span>, Multiplied <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">add = A+B</span><br><span class="line">Multiplied = A*B</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3-1、空白标识符"><a href="#3-1、空白标识符" class="headerlink" title="3.1、空白标识符"></a>3.1、空白标识符</h4><p>_是Go中的空白标识符。它可以代替任何类型的任何值。让我们看看这个空白标识符的用法。<br>比如rectProps函数返回的结果是面积和周长，如果我们只要面积，不要周长，就可以使用空白标识符。<br>示例代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rectProps</span><span class="params">(length, width <span class="keyword">float64</span>)</span> <span class="params">(<span class="keyword">float64</span>, <span class="keyword">float64</span>)</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> area = length * width</span><br><span class="line">    <span class="keyword">var</span> perimeter = (length + width) * <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> area, perimeter</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    area, _ := rectProps(<span class="number">10.8</span>, <span class="number">5.6</span>) <span class="comment">// perimeter is discarded</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;Area %f &quot;</span>, area)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4、defer"><a href="#4、defer" class="headerlink" title="4、defer"></a>4、defer</h3><p>你可以在函数中添加多个defer语句。当函数执行到最后时，这些defer语句会按照逆序执行，最后该函数返回。特别是当你在进行一些打开资源的操作时，遇到错误需要提前返回，在返回前你需要关闭相应的资源，不然很容易造成资源泄露等问题</p>
<ul>
<li>1、如果有很多调用defer，那么defer是采用后进先出模式</li>
<li>2、在离开所在的方法时，执行（报错的时候也会执行）<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadWrite</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    file.Open(<span class="string">&quot;file&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line">    <span class="keyword">if</span> failureX &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; i</span><br><span class="line">    f failureY &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="4-1、延迟参数"><a href="#4-1、延迟参数" class="headerlink" title="4.1、延迟参数"></a>4.1、延迟参数</h4><p>延迟函数的参数在执行延迟语句时被执行，而不是在执行实际的函数调用时执行。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printA</span><span class="params">(a <span class="keyword">int</span>)</span></span> &#123;  </span><br><span class="line">    fmt.Println(<span class="string">&quot;value of a in deferred function&quot;</span>, a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    a := <span class="number">5</span></span><br><span class="line">    <span class="keyword">defer</span> printA(a)</span><br><span class="line">    a = <span class="number">10</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;value of a before deferred function call&quot;</span>, a)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>defer函数：<br>当外围函数中的语句正常执行完毕时，只有其中所有的延迟函数都执行完毕，外围函数才会真正的结束执行。<br>当执行外围函数中的return语句时，只有其中所有的延迟函数都执行完毕后，外围函数才会真正返回。<br>当外围函数中的代码引发运行恐慌时，只有其中所有的延迟函数都执行完毕后，该运行时恐慌才会真正被扩展至调用函数。</p>
<h3 id="5、匿名函数"><a href="#5、匿名函数" class="headerlink" title="5、匿名函数"></a>5、匿名函数</h3><p>匿名函数： Go语言是支持函数式编程： 1.将匿名函数作为另一个函数的参数，回调函数 2.将匿名函数作为另一个函数的返回值，可以形成闭包结构。<br>#</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    匿名：没有名字</span></span><br><span class="line"><span class="comment">        匿名函数：没有名字的函数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    定义一个匿名函数，直接进行调用。通常只能使用一次。也可以使用匿名函数赋值给某个函数变量，那么就可以调用多次了。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    匿名函数：</span></span><br><span class="line"><span class="comment">        Go语言是支持函数式编程：</span></span><br><span class="line"><span class="comment">        1.将匿名函数作为另一个函数的参数，回调函数</span></span><br><span class="line"><span class="comment">        2.将匿名函数作为另一个函数的返回值，可以形成闭包结构。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     fun1()</span><br><span class="line">     fun1()</span><br><span class="line">     fun2 := fun1</span><br><span class="line">     fun2()</span><br><span class="line"></span><br><span class="line">     <span class="comment">//匿名函数</span></span><br><span class="line">     <span class="function"><span class="keyword">func</span> <span class="params">()</span></span>&#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;我是一个匿名函数。。&quot;</span>)</span><br><span class="line">     &#125;()</span><br><span class="line"></span><br><span class="line">     fun3:=<span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;我也是一个匿名函数。。&quot;</span>)</span><br><span class="line">     &#125;</span><br><span class="line">     fun3()</span><br><span class="line">     fun3()</span><br><span class="line"></span><br><span class="line">     <span class="comment">//定义带参数的匿名函数</span></span><br><span class="line">     <span class="function"><span class="keyword">func</span> <span class="params">(a,b <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">        fmt.Println(a,b)</span><br><span class="line">     &#125;(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">     <span class="comment">//定义带返回值的匿名函数</span></span><br><span class="line">     res1 := <span class="function"><span class="keyword">func</span> <span class="params">(a, b <span class="keyword">int</span>)</span><span class="title">int</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b</span><br><span class="line">     &#125;(<span class="number">10</span>,<span class="number">20</span>) <span class="comment">//匿名函数调用了，将执行结果给res1</span></span><br><span class="line">     fmt.Println(res1)</span><br><span class="line"></span><br><span class="line">     res2 := <span class="function"><span class="keyword">func</span> <span class="params">(a,b <span class="keyword">int</span>)</span><span class="title">int</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b</span><br><span class="line">     &#125; <span class="comment">//将匿名函数的值，赋值给res2</span></span><br><span class="line">     fmt.Println(res2)</span><br><span class="line"></span><br><span class="line">     fmt.Println(res2(<span class="number">100</span>,<span class="number">200</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fun1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;我是fun1()函数。。&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="6、回调函数"><a href="#6、回调函数" class="headerlink" title="6、回调函数"></a>6、回调函数</h3><p>回调函数：callback，就是将一个函数fun2作为函数fun1的一个参数。那么fun2叫做回调函数，fun1叫做高阶函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    高阶函数：</span></span><br><span class="line"><span class="comment">        根据go语言的数据类型的特点，可以将一个函数作为另一个函数的参数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    fun1(),fun2()</span></span><br><span class="line"><span class="comment">    将fun1函数作为了fun2这个函数的参数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            fun2函数：就叫高阶函数</span></span><br><span class="line"><span class="comment">                接收了一个函数作为参数的函数，高阶函数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            fun1函数：回调函数</span></span><br><span class="line"><span class="comment">                作为另一个函数的参数的函数，叫做回调函数。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//设计一个函数，用于求两个整数的加减乘除运算</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, add)  <span class="comment">//func(int, int) int</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%T\n&quot;</span>, oper) <span class="comment">//func(int, int, func(int, int) int) int</span></span><br><span class="line"></span><br><span class="line">    res1 := add(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    fmt.Println(res1)</span><br><span class="line"></span><br><span class="line">    res2 := oper(<span class="number">10</span>, <span class="number">20</span>, add)</span><br><span class="line">    fmt.Println(res2)</span><br><span class="line"></span><br><span class="line">    res3 := oper(<span class="number">5</span>,<span class="number">2</span>,sub)</span><br><span class="line">    fmt.Println(res3)</span><br><span class="line"></span><br><span class="line">    fun1:=<span class="function"><span class="keyword">func</span><span class="params">(a,b <span class="keyword">int</span>)</span><span class="title">int</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * b</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res4:=oper(<span class="number">10</span>,<span class="number">4</span>,fun1)</span><br><span class="line">    fmt.Println(res4)</span><br><span class="line"></span><br><span class="line">    res5 := oper(<span class="number">100</span>,<span class="number">8</span>,<span class="function"><span class="keyword">func</span><span class="params">(a,b <span class="keyword">int</span>)</span><span class="title">int</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> b == <span class="number">0</span>&#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;除数不能为零&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a / b</span><br><span class="line">    &#125;)</span><br><span class="line">    fmt.Println(res5)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">oper</span><span class="params">(a, b <span class="keyword">int</span>, fun <span class="keyword">func</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="title">int</span>) <span class="title">int</span></span> &#123;</span><br><span class="line">    fmt.Println(a, b, fun) <span class="comment">//打印3个参数</span></span><br><span class="line">    res := fun(a, b)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加法运算</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//减法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sub</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a - b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>GO基础</category>
      </categories>
      <tags>
        <tag>GO</tag>
      </tags>
  </entry>
  <entry>
    <title>GO集合MAP-day06</title>
    <url>/2021/04/01/GO%E9%9B%86%E5%90%88MAP-day06/</url>
    <content><![CDATA[<h3 id="1、Map"><a href="#1、Map" class="headerlink" title="1、Map"></a>1、Map</h3><p>map是Go中的内置类型，它将一个值与一个键关联起来。可以使用相应的键检索值。<br>Map 是一种无序的键值对的集合。Map 最重要的一点是通过 key 来快速检索数据，key 类似于索引，指向数据的值 Map 是一种集合，所以我们可以像迭代数组和切片那样迭代它。不过，Map 是无序的，我们无法决定它的返回顺序，这是因为 Map 是使用 hash 表来实现的，也是引用类型</p>
<span id="more"></span>
<p>使用map过程中需要注意的几点：</p>
<ul>
<li>1、map是无序的，每次打印出来的map都会不一样，它不能通过index获取，而必须通过key获取</li>
<li>2、map的长度是不固定的，也就是和slice一样，也是一种引用类型</li>
<li>3、内置的len函数同样适用于map，返回map拥有的key的数量</li>
<li>4、map的key可以是所有可比较的类型，如布尔型、整数型、浮点型、复杂型、字符串型……也可以键。</li>
</ul>
<h3 id="2、使用make-创建Map"><a href="#2、使用make-创建Map" class="headerlink" title="2、使用make()创建Map"></a>2、使用make()创建Map</h3><p>可以使用内建函数 make 也可以使用 map 关键字来定义 Map:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 声明变量，默认 map 是 nil */</span></span><br><span class="line"><span class="keyword">var</span> map_variable <span class="keyword">map</span>[key_data_type]value_data_type</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用 make 函数 */</span></span><br><span class="line">map_variable = <span class="built_in">make</span>(<span class="keyword">map</span>[key_data_type]value_data_type)</span><br><span class="line">rating := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">float32</span> &#123;<span class="string">&quot;C&quot;</span>:<span class="number">5</span>, <span class="string">&quot;Go&quot;</span>:<span class="number">4.5</span>, <span class="string">&quot;Python&quot;</span>:<span class="number">4.5</span>, <span class="string">&quot;C++&quot;</span>:<span class="number">2</span> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果不初始化 map，那么就会创建一个 nil map。nil map 不能用来存放键值对</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> countryCapitalMap <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">   <span class="comment">/* 创建集合 */</span></span><br><span class="line">   countryCapitalMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* map 插入 key-value 对，各个国家对应的首都 */</span></span><br><span class="line">   countryCapitalMap[<span class="string">&quot;France&quot;</span>] = <span class="string">&quot;Paris&quot;</span></span><br><span class="line">   countryCapitalMap[<span class="string">&quot;Italy&quot;</span>] = <span class="string">&quot;Rome&quot;</span></span><br><span class="line">   countryCapitalMap[<span class="string">&quot;Japan&quot;</span>] = <span class="string">&quot;Tokyo&quot;</span></span><br><span class="line">   countryCapitalMap[<span class="string">&quot;India&quot;</span>] = <span class="string">&quot;New Delhi&quot;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 使用 key 输出 map 值 */</span></span><br><span class="line">   <span class="keyword">for</span> country := <span class="keyword">range</span> countryCapitalMap &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;Capital of&quot;</span>,country,<span class="string">&quot;is&quot;</span>,countryCapitalMap[country])</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 查看元素在集合中是否存在 */</span></span><br><span class="line">   captial, ok := countryCapitalMap[<span class="string">&quot;United States&quot;</span>]</span><br><span class="line">   <span class="comment">/* 如果 ok 是 true, 则存在，否则不存在 */</span></span><br><span class="line">   <span class="keyword">if</span>(ok)&#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;Capital of United States is&quot;</span>, captial)  </span><br><span class="line">   &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">&quot;Capital of United States is not present&quot;</span>) </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="3、delete-map-key"><a href="#3、delete-map-key" class="headerlink" title="3、delete(map, key)"></a>3、delete(map, key)</h3><p>delete(map, key) 函数用于删除集合的元素, 参数为 map 和其对应的 key。删除函数不返回任何值。</p>
]]></content>
      <categories>
        <category>GO基础</category>
      </categories>
      <tags>
        <tag>GO</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务入门-day01</title>
    <url>/2021/04/05/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%85%A5%E9%97%A8-day01/</url>
    <content><![CDATA[<h3 id="1、微服务"><a href="#1、微服务" class="headerlink" title="1、微服务"></a>1、微服务</h3><ul>
<li>1、<strong>服务拆分粒度更细</strong>。</li>
<li>2、<strong>服务独立部署</strong>。</li>
<li>3、<strong>服务独立维护</strong>。</li>
<li>4、<strong>服务治理能力要求高</strong><span id="more"></span>
<h3 id="2、单体应用拆分成微服务的正确姿势"><a href="#2、单体应用拆分成微服务的正确姿势" class="headerlink" title="2、单体应用拆分成微服务的正确姿势"></a>2、单体应用拆分成微服务的正确姿势</h3>根据实际项目经验，一旦单体应用同时进行开发的人员超过 10 人，就会遇到上面的问题，这个时候就该考虑进行服务化拆分了。</li>
</ul>
<h5 id="2-1、服务拆分的姿势"><a href="#2-1、服务拆分的姿势" class="headerlink" title="2.1、服务拆分的姿势"></a>2.1、服务拆分的姿势</h5><ul>
<li>1、<strong>纵向拆分</strong>。是从业务纬度进行拆分，标准是按照业务的关联程度来决定，关联比较密切的业务适合拆分为一个微服务，而功能相对独立的业务适合单独拆分为一个微服务。</li>
<li>2、<strong>横向拆分</strong>。是从公共且独立功能纬度拆分，标准是按照是否有公共的被多个其他服务调用，且依赖的资源独立不与其他业务耦合。</li>
</ul>
<h5 id="2-2、服务化拆分的前提条件"><a href="#2-2、服务化拆分的前提条件" class="headerlink" title="2.2、服务化拆分的前提条件"></a>2.2、服务化拆分的前提条件</h5><ul>
<li>1、<strong>服务如何定义</strong>。服务之间的调用都通过接口描述来约定，包括接口名、入参、出参</li>
<li>2、<strong>服务如何发布和订阅</strong>。</li>
<li>3、<strong>服务如何监控</strong>。通常对于一个服务，我们最关心的是 QPS（调用量）、AvgTime（平均耗时）以及 P999（99.9% 的请求性能在多少毫秒以内）这些指标。</li>
<li>4、<strong>服务如何治理</strong>。</li>
<li>5、<strong>故障如何定位</strong>。 </li>
</ul>
<h3 id="3、微服务架构"><a href="#3、微服务架构" class="headerlink" title="3、微服务架构"></a>3、微服务架构</h3><p><img src="http://free-cn-01.cdn.bilnn.com/ddfilesass/jfs/t1/175197/6/2341/121126/606c6a6cEf77e473c/db92ce5646720d3f.png" alt="服务调用流程"><br>微服务架构下，服务调用主要依赖下面几个基本组件：</p>
<ul>
<li>1、服务描述</li>
<li>2、注册中心</li>
<li>3、服务框架</li>
<li>4、服务监控</li>
<li>5、服务追踪</li>
<li>6、服务治理</li>
</ul>
<h5 id="3-1、服务描述"><a href="#3-1、服务描述" class="headerlink" title="3.1、服务描述"></a>3.1、服务描述</h5><p>服务调用首先要解决的问题就是服务如何对外描述。常用的服务描述方式包括RESTful API、XML配置以及IDL文件三种。</p>
<ul>
<li>1、RESTful API方式通常用于HTTP协议的服务描述。</li>
<li>2、XML 配置方式多用作 RPC 协议的服务描述，通过 *.xml 配置文件来定义接口名、参数以及返回值类型等。</li>
<li>3、IDL 文件方式通常用作 Thrift 和 gRPC 这类跨语言服务调用框架中，比如 gRPC 就是通过 Protobuf 文件来定义服务的接口名、参数以及返回值的数据结构。</li>
</ul>
<h5 id="3-2、注册中心"><a href="#3-2、注册中心" class="headerlink" title="3.2、注册中心"></a>3.2、注册中心</h5><p>注册中心的工作流程：</p>
<ul>
<li>1、服务提供者在启动时，根据服务发布文件中配置的发布信息向注册中心注册自己的服务。</li>
<li>2、服务消费者在启动时，根据消费者配置文件中配置的服务信息向注册中心订阅自己所需要的服务。</li>
<li>3、注册中心返回服务提供者地址列表给服务消费者</li>
<li>4、当服务提供者发生变化，比如有节点新增或者销毁，注册中心将变更通知给服务消费者。</li>
</ul>
<h5 id="3-3、服务框架"><a href="#3-3、服务框架" class="headerlink" title="3.3、服务框架"></a>3.3、服务框架</h5><h5 id="3-4、服务监控"><a href="#3-4、服务监控" class="headerlink" title="3.4、服务监控"></a>3.4、服务监控</h5><p>服务监控主要包括三个流程：</p>
<ul>
<li>1、指标收集。就是要把每一次服务调用的请求耗时以及成功与否收集起来，并上传到集中的数据处理中心。</li>
<li>2、数据处理。有了每次调用的请求耗时以及成功与否等信息，就可以计算每秒服务请求量、平均耗时以及成功率等指标。</li>
<li>3、数据展示。数据收集起来，经过处理之后，还需要以友好的方式对外展示，才能发挥价值。通常都是将数据展示在 Dashboard 面板上，并且每隔 10s 等间隔自动刷新，用作业务监控和报警等。</li>
</ul>
<h5 id="3-5、服务追踪"><a href="#3-5、服务追踪" class="headerlink" title="3.5、服务追踪"></a>3.5、服务追踪</h5><ul>
<li> 服务消费者发起调用前，会在本地按照一定的规则生成一个 requestid，发起调用时，将 requestid 当作请求参数的一部分，传递给服务提供者。</li>
<li> 服务提供者接收到请求后，记录下这次请求的 requestid，然后处理请求。如果服务提供者继续请求其他服务，会在本地再生成一个自己的 requestid，然后把这两个 requestid 都当作请求参数继续往下传递。</li>
</ul>
<h5 id="3-6、服务治理"><a href="#3-6、服务治理" class="headerlink" title="3.6、服务治理"></a>3.6、服务治理</h5>]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>极客时间《从0开始学微服务》</tag>
      </tags>
  </entry>
</search>
