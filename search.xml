<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>mysql 5.7虚拟列 generated columns</title>
    <url>/2021/03/14/mysql-5-7%E8%99%9A%E6%8B%9F%E5%88%97-generated-columns/</url>
    <content><![CDATA[<h3 id="CREATE-TABLE-支持生成的列"><a href="#CREATE-TABLE-支持生成的列" class="headerlink" title="CREATE TABLE 支持生成的列"></a>CREATE TABLE 支持生成的列</h3><p>生成列的值是根据列定义中包含的表达式计算的。<br>下面的简单示例的表，该表存储了 sidea 和 sideb 列中直角三角形的长度，并计算了sidec 中斜边的长度:<span id="more"></span></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> triangle(</span><br><span class="line">    sidea <span class="keyword">DOUBLE</span>,</span><br><span class="line">    sideb <span class="keyword">DOUBLE</span>,</span><br><span class="line">    sidec <span class="keyword">DOUBLE</span> <span class="keyword">AS</span> (<span class="built_in">SQRT</span>(sidea <span class="operator">*</span> sidea <span class="operator">+</span> sideb <span class="operator">*</span> sideb))</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> triangle (sidea, sideb) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">1</span>), (<span class="number">3</span>, <span class="number">4</span>), (<span class="number">6</span>, <span class="number">8</span>);</span><br></pre></td></tr></table></figure>
<p>从表中选择会产生以下结果,使用 triangle 表的任何应用程序都可以访问斜边值，而无需指定计算它们的表达式。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> triangle;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------+--------------------+</span></span><br><span class="line"><span class="operator">|</span> sidea <span class="operator">|</span> sideb <span class="operator">|</span> sidec              <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------+--------------------+</span></span><br><span class="line"><span class="operator">|</span>     <span class="number">1</span> <span class="operator">|</span>     <span class="number">1</span> <span class="operator">|</span> <span class="number">1.4142135623730951</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>     <span class="number">3</span> <span class="operator">|</span>     <span class="number">4</span> <span class="operator">|</span>                  <span class="number">5</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>     <span class="number">6</span> <span class="operator">|</span>     <span class="number">8</span> <span class="operator">|</span>                 <span class="number">10</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-------+--------------------+</span></span><br></pre></td></tr></table></figure>
<p>生成的列的定义具有以下语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `table_name` <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> `col_name` datatype [GENRATED ALWAYS] <span class="keyword">AS</span> (expr) [VIRTUAL <span class="operator">|</span> STORED] [<span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>] [<span class="keyword">UNIQUE</span> [KEY]] [[<span class="keyword">PRIMARY</span>] KEY]</span><br><span class="line">[COMMENT <span class="string">&#x27;string&#x27;</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>AS (expr)表示生成列并定义用于计算列值的表达式。AS 之前可能有 GENRATED ALWAYS,以使列的生成性质更加明确。</li>
<li>VIRTUAL 或 STORED 关键字指示如何存储列值，如果未指定任何关键字，则默认值为 VIRTUAL.<ul>
<li>VIRTUAL：不存储列值，但在任何 BEFORE 触发后立即读取行时计算列值。虚拟列不占用存储空间。InnoDB 支持虚拟列上的二级索引。</li>
<li>STORED：插入或更新行时，将评估和存储列值。存储的列需要存储空间并且可以设置索引。</li>
</ul>
</li>
</ul>
<p>允许在表中混合 VIRTUAL 和 STORED 列。<br>生成的列表达式必须遵守以下规则。如果表达式不允许的构造，则会发生错误：</p>
<ul>
<li>允许使用文字，确定性内置函数和运算符。即要符合幂等。非确定函数的：CONNECTION_ID(), CURRENT_USER(), NOW()等。</li>
<li>不允许存储函数和用户自定义函数。</li>
<li>不允许存储过程和函数参数。</li>
<li>不允许使用变量。（系统变量，用户自定义的变量和存储的程序局部变量）。</li>
<li>不允许使用子查询。</li>
<li>生成的列定义可以引用其他生成的列，但只能用表定义中较早出现的列。生成的列定义可以引用表中的任何基本（非生成）列，无论其定义是早期还是稍后</li>
<li>AUTO_INCREMENT 属性不能在生成的列定义中使用。</li>
<li>AUTO_INCREMENT 列不能用作生成的列定义中的基本列。</li>
</ul>
<p>存储的生成列上的外键约束不能使用 ON UPDATE CASCADE, ON DELETE SET NULL, ON UPDATE SET NULL, ON DELETE SET DEFAULT 或 ON UPDATE SET DEFAULT。<br>外键约束不能引用虚拟生成的列。<br>生成的列有几个用例，例如：</p>
<ul>
<li>虚拟生成列可用作简化和统一查询的方法。一个复杂的条件可以定义为生成的列，并从表上的多个查询引用，以确保它们都使用完全相同的条件</li>
<li>存储生成列可用作物化缓存，用于复杂条件，这些条件在运行中计算成本很高。</li>
<li>生成的列可以模拟功能索引：使用生成的列定义功能表达式并对其进行索引。这对处理无法直接索引的类型列非常有用</li>
<li>对于存储的生成列，这种方法的缺点是值存储两次；一次作为生成列的值，一次作为索引</li>
</ul>
]]></content>
      <categories>
        <category>mySQL</category>
      </categories>
  </entry>
  <entry>
    <title>高性能MYSQL-读书笔记之索引(一)</title>
    <url>/2021/03/13/%E9%AB%98%E6%80%A7%E8%83%BDMYSQL-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%B4%A2%E5%BC%95-%E4%B8%80/</url>
    <content><![CDATA[<h3 id="索引基础"><a href="#索引基础" class="headerlink" title="索引基础"></a>索引基础</h3><h4 id="索引的类型"><a href="#索引的类型" class="headerlink" title="索引的类型"></a>索引的类型</h4><h5 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B-Tree索引"></a>B-Tree索引</h5><p>目前大部分数据库系统及文件系统都采用B-Tree或其变种B+Tree作为索引结构.<br>存储引擎以不同的方式使用B-Tree索引：</p>
<ul>
<li>MyISAM使用前缀压缩技术使得索引更小；MyISAM索引通过数据的无力位置引用被索引的行</li>
<li>InnoDB则按照原数据格式进行存储；InnoDB根据主键引用被索引的行</li>
</ul>
<p>可使用B-Tree索引的查询类型。B-Tree索引适用于全键值、键值范围或键前缀查找：</p>
<span id="more"></span>
<ul>
<li>全值匹配：和索引种的所有列进行匹配</li>
<li>匹配最左前缀：使用索引的第一列</li>
<li>匹配列前缀：匹配某一列的值的开头部分</li>
<li>匹配范围值：</li>
<li>精确匹配某一列并范围匹配另外一列</li>
<li>只访问索引的查询</li>
</ul>
<p>因为索引树中的结点是有序的，所以索引除了查找之外，还可以用于查询种的 ORDER BY 操作。只要 ORDER BY 子句满足以上的查询类型，则这个索引也可以满足排序需求</p>
<p>关于B-Tree索引的限制：</p>
<ul>
<li>如果不是按照索引的最左列开始查找，则无法使用索引</li>
<li>不能跳过索引中的列</li>
<li>如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找</li>
</ul>
<h4 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h4><p>哈希索引(hash index)基于哈希表实现，只有精确匹配索引所有列的查询才有效。<br>哈希索引的缺点：</p>
<ul>
<li>哈希索引只包含哈希值和行指针，不存储字段值，导致不能使用索引中的值来避免读取行</li>
<li>哈希索引数据并不是按照索引值顺序存储的，无法用于排序</li>
<li>哈希表不支持部分索引列匹配查找，因为哈希索引始终使用索引列的全部内容来计算哈希值的。例如，在数据列（A，B）上建立哈希索引，如果只查询A列，则无法使用索引</li>
<li>哈希只支持等值比较查询，包括=、IN()、&gt;、&lt;,不支持任何范围查询</li>
<li>如果哈希冲突很多，索引维护的代价会很高</li>
</ul>
<h4 id="空间数据索引"><a href="#空间数据索引" class="headerlink" title="空间数据索引"></a>空间数据索引</h4><h5 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h5><p>索引的优点<br>总结三个优点：</p>
<ul>
<li>1、索引大大减少了服务器需要扫描的数据量</li>
<li>2、索引可以帮助服务器避免排序和临时表</li>
<li>3、索引可以将随机I/O变为顺序I/O</li>
</ul>
]]></content>
      <categories>
        <category>mySQL</category>
      </categories>
  </entry>
  <entry>
    <title>高性能MYSQL-读书笔记之索引(二)</title>
    <url>/2021/03/14/%E9%AB%98%E6%80%A7%E8%83%BDMYSQL-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%B4%A2%E5%BC%95-%E4%BA%8C/</url>
    <content><![CDATA[<h3 id="高性能索引策略"><a href="#高性能索引策略" class="headerlink" title="高性能索引策略"></a>高性能索引策略</h3><p>正确的创建和使用索引是实现高性能查询的基础。</p>
<h4 id="独立的列"><a href="#独立的列" class="headerlink" title="独立的列"></a>独立的列</h4><p>“独立的列”是指索引列不能是表达式的一部分，也不能是函数的参数。举个例子：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">## 下面这个查询无法使用actor_id列的索引</span><br><span class="line"><span class="keyword">SELECT</span> actor_id <span class="keyword">FROM</span> sakila.actor <span class="keyword">WHERE</span> actor_id <span class="operator">+</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<h4 id="前缀索引和索引选择性"><a href="#前缀索引和索引选择性" class="headerlink" title="前缀索引和索引选择性"></a>前缀索引和索引选择性</h4><p>当需要索引很长的字符列时，会让索引变得大且慢。<span id="more"></span>通常可以索引开始的部分字符，可以减少索引空间，提高索引效率。但这样操作会降低索引的选择性。索引的选择性是指，不重复的索引值和数据表的记录总数(#T)的比值，范围在 1/#T到1之间。索引的选择性越高则查询效率越高。对于 BLOB、TEXT或很长的VARCHAR类型的列，必须使用前缀索引，因为MYSQL不允许这些列的完整长度。在使用前缀索引时，要选择足够长的前缀以保证较高的选择性，同时又不能太长。如何确定呢？举个例子:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">LEFT</span>(city, <span class="number">3</span>)) <span class="operator">/</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> sel3 <span class="keyword">FROM</span> sakila.city_demo;       ## <span class="number">0.0239</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">LEFT</span>(city, <span class="number">4</span>)) <span class="operator">/</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> sel4 <span class="keyword">FROM</span> sakila.city_demo;       ## <span class="number">0.0293</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">LEFT</span>(city, <span class="number">5</span>)) <span class="operator">/</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> sel5 <span class="keyword">FROM</span> sakila.city_demo;       ## <span class="number">0.0305</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">LEFT</span>(city, <span class="number">6</span>)) <span class="operator">/</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> sel6 <span class="keyword">FROM</span> sakila.city_demo;       ## <span class="number">0.0309</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> <span class="keyword">LEFT</span>(city, <span class="number">7</span>)) <span class="operator">/</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> sel7 <span class="keyword">FROM</span> sakila.city_demo;       ## <span class="number">0.0310</span> 查询显示长度为<span class="number">7</span>时，最接近</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> city) <span class="operator">/</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> selAll <span class="keyword">FROM</span> sakila.city_demo;   ## <span class="number">0.0312</span></span><br><span class="line">## 只看平均选择性是不够的，需要考虑最坏情况下的选择性</span><br></pre></td></tr></table></figure>
<p>当找到合适的前缀长度，就要创建前缀索引列，如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> sakila.city_demo <span class="keyword">ADD</span> KEY(city(<span class="number">7</span>));</span><br></pre></td></tr></table></figure>
<p>前缀索引需要注意的是MYSQL无法使用前缀索引做 ORDER BY 和 GROUP BY，也无法使用前缀索引做覆盖扫描。</p>
<h4 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h4><p>在多个列上建立独立的单列索引大部分情况下并不能提高MYSQL的查询性能。索引合并策略有时候是一种优化的结果，但实际上更多时候说明了表上的索引建的很糟糕。</p>
<h4 id="选择合适的索引列顺序"><a href="#选择合适的索引列顺序" class="headerlink" title="选择合适的索引列顺序"></a>选择合适的索引列顺序</h4><h4 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h4><p>聚簇索引并不是单独的索引类型，而是一种数据存储方式。当表有聚簇索引时，它的数据行实际存放在索引的叶子页(leaf page)中。一个表只能有一个聚簇索引。优点：</p>
<ul>
<li>可以把相关数据保存在一起</li>
<li>数据访问更快</li>
<li>使用覆盖索引扫描的查询可以直接使用页节点中的主键值。</li>
</ul>
<p>缺点：</p>
<ul>
<li>插入速度严重依赖插入顺序。如果不是按照主键顺序加载数据，那么加载完成后最好使用OPTIMIZE TABLE命令重新组织一下表</li>
<li>更新聚簇索引列的代价很高，因为会强制InnoDB将每个被更新的行移动到新的位置</li>
<li>基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临“页分裂(page split)”的问题。</li>
<li>聚簇索引可能导致全表扫描变慢</li>
<li>二级索引(非聚簇索引)可能比想象的更大，因为在二级索引的叶子结点包含了引用行的主键列</li>
<li>二级索引访问需要两次索引查找</li>
</ul>
<h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>如果一个索引包含或者说覆盖所有需要查询的字段的值，就是“覆盖索引”。覆盖索引的优点：</p>
<ul>
<li>索引条目通常远小于数据行大小</li>
<li>如果二级主键能够覆盖查询，则可以避免对主键索引的二次查询。覆盖索引必须要存储索引列的值，而哈希索引、空间索引、全文索引等都不存储，所以只能使用B-Tree索引做覆盖索引。</li>
</ul>
<h4 id="使用索引扫描来做排序"><a href="#使用索引扫描来做排序" class="headerlink" title="使用索引扫描来做排序"></a>使用索引扫描来做排序</h4><p>MySQL有两种方式可以生成有序的结果：</p>
<ul>
<li>通过排序操作</li>
<li>按索引顺序扫描。如果EXPLAIN出来的type列的值为“index”，则说明使用了索引扫描做排序</li>
</ul>
<p>满足索引做排序的条件如下：</p>
<ul>
<li>只有当索引的列顺序和ORDER BY子句的顺序完全一致，且所有的列的排序方向都一样时，MySQL才能使用索引对结果排序。</li>
<li>如果需要联表查询，则只有当ORDER BY子句引用的字段全部为第一个表时，才能使用索引做排序。</li>
<li>ORDER BY子句和查询的限制一样：需要满足索引的最左前缀要求<br>示例：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">## rental表中有以下索引：</span><br><span class="line">## <span class="keyword">UNIQUE</span> KEY rental_date(rental_date, inventory_id, customer_id)</span><br><span class="line">## key idx_fk_inventory_id(inventory_id)</span><br><span class="line">## key_idx_fk_customer_id(customer_id)</span><br><span class="line">## key_idx_fk_staff_id(staff_id)</span><br><span class="line">## 这个查询可以利用索引排序，因为索引的第一列提供了常量条件,而使用第二列排序，将两列组合，就符合索引的最左前缀</span><br><span class="line"><span class="keyword">SELECT</span> rental_id, staff_id <span class="keyword">FROM</span> sakila.rental <span class="keyword">WHERE</span> rental_date <span class="operator">=</span> <span class="string">&#x27;2019-03-31&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> inventory_id <span class="keyword">DESC</span>;</span><br><span class="line"></span><br><span class="line">## 这个也可以索引排序,因为<span class="keyword">ORDER</span> <span class="keyword">BY</span> 使用的两列就是索引的最左前缀</span><br><span class="line"><span class="keyword">SELECT</span> rental_id, staff_id <span class="keyword">FROM</span> sakila.rental <span class="keyword">WHERE</span> rental_date <span class="operator">&lt;</span> <span class="string">&#x27;2019-03-31&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> rental_date, inventory_id;</span><br><span class="line"></span><br><span class="line">## 下面是一些不能使用索引做排序的查询</span><br><span class="line">## 这个查询使用了两种不同的排序方向，但索引列都是正序排序的</span><br><span class="line"><span class="keyword">SELECT</span> rental_id, staff_id <span class="keyword">FROM</span> sakila.rental <span class="keyword">WHERE</span> rental_date <span class="operator">=</span> <span class="string">&#x27;2019-03-31&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> inventory_id <span class="keyword">DESC</span>, customer_id <span class="keyword">ASC</span>;</span><br><span class="line">## 这个查询的<span class="keyword">ORDER</span> <span class="keyword">BY</span> 子句中引用了一个不在索引中的列</span><br><span class="line"><span class="keyword">SELECT</span> rental_id, staff_id <span class="keyword">FROM</span> sakila.rental <span class="keyword">WHERE</span> rental_date <span class="operator">=</span> <span class="string">&#x27;2019-03-31&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> inventory_id, staff_id;</span><br><span class="line">## 这个查询的<span class="keyword">WHERE</span>和<span class="keyword">ORDER</span> <span class="keyword">BY</span>中的列无法组合成索引的最左前缀</span><br><span class="line"><span class="keyword">SELECT</span> rental_id, staff_id <span class="keyword">FROM</span> sakila.rental <span class="keyword">WHERE</span> rental_date <span class="operator">=</span> <span class="string">&#x27;2019-03-31&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> customer_id;</span><br><span class="line">##  这个查询在索引列的第一列上是范围条件，所以无法使用索引的其余列</span><br><span class="line"><span class="keyword">SELECT</span> rental_id, staff_id <span class="keyword">FROM</span> sakila.rental <span class="keyword">WHERE</span> rental_date <span class="operator">&gt;</span> <span class="string">&#x27;2019-03-31&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> inventory_id, customer_id;</span><br><span class="line">## 这个查询在inventory_id列上有多个等于条件。对于排序来说，这也是一种范围查询</span><br><span class="line"><span class="keyword">SELECT</span> rental_id, staff_id <span class="keyword">FROM</span> sakila.rental <span class="keyword">WHERE</span> rental_date <span class="operator">=</span> <span class="string">&#x27;2019-03-31&#x27;</span> <span class="keyword">AND</span> inventory_id <span class="keyword">IN</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="keyword">ORDER</span> <span class="keyword">BY</span> customer_id;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="冗余和重复的索引"><a href="#冗余和重复的索引" class="headerlink" title="冗余和重复的索引"></a>冗余和重复的索引</h4><p>重复索引是指在相同的列上按照相同的顺序创建相同类型的索引。应该避免重复索引。冗余索引和重复索引有一些不同。例如：</p>
<ul>
<li>创建了索引(A, B)，在创建索引(A)就是冗余索引，因为这只是前一个索引的前缀索引</li>
<li>创建了索引(A, B)，在创建索引(B, A)，则不是冗余索引，索引(B)也不是</li>
</ul>
]]></content>
      <categories>
        <category>mySQL</category>
      </categories>
  </entry>
</search>
